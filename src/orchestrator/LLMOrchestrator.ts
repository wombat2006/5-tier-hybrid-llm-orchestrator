import { 
  SystemConfig,
  LLMRequest,
  LLMResponse,
  BaseLLMClient,
  TaskType,
  ModelConfig,
  CollaborationRequest,
  CollaborationResponse,
  SystemMetrics
} from '../types';
import { ClaudeCodeQueryAnalyzer, ModelSuitabilityAnalyzer, QueryAnalysis } from '../analysis/QueryAnalyzer';
import { ContextAwareQueryAnalyzer } from '../analysis/ContextAwareQueryAnalyzer';
import { 
  Subtask, 
  DecompositionRequest, 
  DecompositionResult, 
  CollaborativeConfig, 
  CodingSession, 
  CodeResult,
  SubtaskStatus
} from '../types/collaborative';
import { ConfigLoader } from '../utils/ConfigLoader';
import { QwenCoderAPIClient } from '../clients/QwenCoderClient';
import { OpenRouterAPIClient } from '../clients/OpenRouterClient';
import { GeminiAPIClient } from '../clients/GeminiClient';
import { MockQwenClient } from '../clients/MockQwenClient';
import { AnthropicAPIClient } from '../clients/AnthropicClient';
import { OpenAIAPIClient } from '../clients/OpenAIClient';
import { OpenRouterModelRegistry } from '../services/OpenRouterModelRegistry';
import { ModelAliasResolver } from '../services/ModelAliasResolver';
// CLIÈñ¢ÈÄ£„ÅÆimport„ÇíÂâäÈô§ - ToolOrchestratorService„Å´ÁßªË°å
import { TaskDecomposer } from '../pipeline/TaskDecomposer';
import { DifficultyClassifier } from '../pipeline/DifficultyClassifier';
import { QualityGate } from '../pipeline/QualityGate';
import { PrecisionCostManagementSystem } from '../management/CostManagementSystem';
import { CostManagementSystem, TokenUsage } from '../types/cost-management';
import { DefaultCapabilityRegistry } from '../services/CapabilityRegistry';
import { CapabilityRegistry, CapabilityProvider } from '../types/capability';
import { ConversationManager } from '../services/ConversationManager';
import { OpenAIAssistantProvider } from '../services/OpenAIAssistantProvider';
import { AssistantConfig } from '../types/assistant';
import RedisLogger, { QueryAnalysisLog } from '../utils/RedisLogger';
import UpstashRedisLogger from '../utils/UpstashRedisLogger';
import LogAnalysisService, { LogAnalysisRequest } from '../services/LogAnalysisService';
import InteractiveTroubleshooter from '../services/InteractiveTroubleshooter';
import AdvancedLogAnalyzer, { LogAnalysisContext } from '../services/AdvancedLogAnalyzer';
import SafeExecutionManager from '../services/SafeExecutionManager';

export class LLMOrchestrator {
  private config: SystemConfig;
  private clients: Map<string, BaseLLMClient> = new Map();
  private metrics: SystemMetrics = {
    requests_per_tier: { 0: 0, 1: 0, 2: 0, 3: 0 },
    success_rate_per_tier: { 0: 0, 1: 0, 2: 0, 3: 0 },
    average_latency_per_tier: { 0: 0, 1: 0, 2: 0, 3: 0 },
    cost_per_tier: { 0: 0, 1: 0, 2: 0, 3: 0 },
    total_monthly_spend: 0,
    budget_utilization_percentage: 0,
    most_used_capabilities: [],
    error_distribution: {}
  };
  private monthlySpend: number = 0;
  private requestCount: number = 0;
  
  // ÂçîË™ø„Éï„É≠„Éº„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà
  private taskDecomposer!: TaskDecomposer;
  private difficultyClassifier!: DifficultyClassifier;
  private qualityGate!: QualityGate;
  private collaborativeConfig!: CollaborativeConfig;
  private activeSessions: Map<string, CodingSession> = new Map();
  
  // IT Troubleshooting Services
  private logAnalysisService!: LogAnalysisService;
  private interactiveTroubleshooter!: InteractiveTroubleshooter;
  private advancedLogAnalyzer!: AdvancedLogAnalyzer;
  private safeExecutionManager!: SafeExecutionManager;
  
  // „Ç≥„Çπ„ÉàÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†
  private costManagement!: CostManagementSystem;
  
  // CapabilityÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†
  private capabilityRegistry!: CapabilityRegistry;
  
  // OpenRouter Model Registry
  private openRouterRegistry: OpenRouterModelRegistry | undefined;
  
  // Model Alias ResolverÔºàÂÖ¨Âºè„Ç®„Ç§„É™„Ç¢„ÇπÂØæÂøúÔºâ
  private aliasResolver!: ModelAliasResolver;
  
  // Áü•ÁöÑÂàÜÊûê„Ç∑„Çπ„ÉÜ„É†ÔºàClaude Code‰∏ªÂ∞éÔºâ
  private queryAnalyzer!: ClaudeCodeQueryAnalyzer;
  private contextAwareAnalyzer!: ContextAwareQueryAnalyzer;
  private suitabilityAnalyzer!: ModelSuitabilityAnalyzer;
  
  // RedisÁµ±Âêà„É≠„Ç∞„Ç∑„Çπ„ÉÜ„É†ÔºàUpstashÂØæÂøúÔºâ
  private redisLogger!: RedisLogger | UpstashRedisLogger;
  
  // ‰ºöË©±„Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†
  private conversationManager!: ConversationManager;
  
  // CLI Interface Manager removed - moved to ToolOrchestratorService

  constructor(configPath?: string) {
    console.log('[LLMOrchestrator] Initializing 5-Tier Hybrid LLM System with Collaborative Coding...');
    
    const configLoader = ConfigLoader.getInstance();
    this.config = configLoader.loadConfig(configPath);
    
    // Áí∞Â¢ÉÂ§âÊï∞Ê§úË®º
    const envCheck = configLoader.validateEnvironmentVariables();
    if (!envCheck.valid) {
      console.warn('[LLMOrchestrator] Missing environment variables:', envCheck.missingVars);
    }
    if (envCheck.warnings.length > 0) {
      console.warn('[LLMOrchestrator] Environment warnings:', envCheck.warnings);
    }

    this.initializeAliasResolver();
    // CLI Manager initialization moved to ToolOrchestratorService
    this.initializeOpenRouterRegistry();
    this.initializeClients();
    this.initializeMetrics();
    this.initializeIntelligentAnalyzer();
    this.initializeCollaborativeComponents();
    this.initializeCapabilityRegistry();
    
    // RedisÁµ±Âêà„É≠„Ç∞„Ç∑„Çπ„ÉÜ„É†ÂàùÊúüÂåñ
    this.initializeRedisLogger();
    
    // ‰ºöË©±„Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†ÂàùÊúüÂåñ
    this.initializeConversationManager();
    
    // IT Troubleshooting Services ÂàùÊúüÂåñ
    this.initializeITTroubleshootingServices();
    
    // „Ç≥„Çπ„ÉàÁÆ°ÁêÜ„ÅØÈùûÂêåÊúü„ÅßÂàùÊúüÂåñ
    this.initializeCostManagement().catch(error => {
      console.warn('[LLMOrchestrator] Cost management initialization failed:', error);
    });
    
    // Êó•Ê¨°„Ç≥„Çπ„ÉàÊõ¥Êñ∞„Çπ„Ç±„Ç∏„É•„Éº„É©„ÉºÈñãÂßã
    this.startDailyCostScheduler();
    
    console.log('[LLMOrchestrator] ‚úÖ System initialized successfully');
    this.printSystemSummary();
  }

  private initializeAliasResolver(): void {
    console.log('[LLMOrchestrator] Initializing Model Alias Resolver...');
    
    try {
      this.aliasResolver = ModelAliasResolver.getInstance();
      this.aliasResolver.loadConfig('./config/model-aliases.yaml');
      
      const stats = this.aliasResolver.getStats();
      console.log(`[LLMOrchestrator] ‚úÖ Model Alias Resolver initialized: ${stats.providers} providers, ${stats.total_aliases} aliases, ${stats.official_alias_providers} official`);
      
    } catch (error) {
      console.error('[LLMOrchestrator] ‚ùå Failed to initialize Model Alias Resolver:', error);
      throw error;
    }
  }

  // initializeCLIManager method removed - moved to ToolOrchestratorService

  private initializeClients(): void {
    console.log('[LLMOrchestrator] Initializing API clients...');

    for (const [modelId, modelConfig] of Object.entries(this.config.models)) {
      try {
        let client: BaseLLMClient;
        
        // „Ç®„Ç§„É™„Ç¢„ÇπËß£Ê±∫„Åß„É¢„Éá„É´Âêç„ÇíÂèñÂæó
        const resolvedModelName = this.aliasResolver.resolveAlias(modelConfig.name);
        console.log(`[LLMOrchestrator] üîÑ Resolved model alias: ${modelConfig.name} ‚Üí ${resolvedModelName}`);

        switch (modelConfig.provider) {
          case 'alibaba_cloud':
            // Áí∞Â¢ÉÂ§âÊï∞„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØMock„ÇØ„É©„Ç§„Ç¢„É≥„Éà„Çí‰ΩøÁî®
            if (!process.env.ALIBABA_ACCESS_KEY_ID || !process.env.ALIBABA_ACCESS_KEY_SECRET) {
              console.log(`[LLMOrchestrator] üîÑ Using Mock Qwen3 Coder client (missing credentials)`);
              client = new MockQwenClient();
            } else {
              client = new QwenCoderAPIClient();
            }
            console.log(`[LLMOrchestrator] ‚úÖ Qwen3 Coder client initialized (Tier ${modelConfig.tier})`);
            break;
          
          case 'openrouter':
            // OpenRouterÁµåÁî±„ÅßQwen3-Coder„Çí‰ΩøÁî®
            if (!process.env.OPENROUTER_API_KEY) {
              console.log(`[LLMOrchestrator] üîÑ Using Mock Qwen3 Coder client (missing OpenRouter credentials)`);
              client = new MockQwenClient();
            } else {
              client = new OpenRouterAPIClient(resolvedModelName);
            }
            console.log(`[LLMOrchestrator] ‚úÖ OpenRouter Qwen3 Coder client initialized (Tier ${modelConfig.tier})`);
            break;
          
          case 'google':
            client = new GeminiAPIClient(resolvedModelName);
            console.log(`[LLMOrchestrator] ‚úÖ Gemini client initialized: ${resolvedModelName} (Tier ${modelConfig.tier})`);
            break;
          
          case 'anthropic':
            client = new AnthropicAPIClient(resolvedModelName);
            console.log(`[LLMOrchestrator] ‚úÖ Anthropic client initialized: ${resolvedModelName} (${modelId})`);
            break;
          
          case 'openai':
            client = new OpenAIAPIClient(resolvedModelName);
            console.log(`[LLMOrchestrator] ‚úÖ OpenAI client initialized: ${resolvedModelName} (${modelId})`);
            break;
          
          default:
            console.error(`[LLMOrchestrator] ‚ùå Unknown provider: ${modelConfig.provider} for model ${modelId}`);
            continue;
        }

        this.clients.set(modelId, client);

      } catch (error) {
        console.error(`[LLMOrchestrator] ‚ùå Failed to initialize client for ${modelId}:`, error);
      }
    }

    // OpenRouter Registry „Åã„Çâ„ÅÆÂãïÁöÑ„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂàùÊúüÂåñ
    if (this.openRouterRegistry) {
      this.initializeOpenRouterClients();
    }

    console.log(`[LLMOrchestrator] Initialized ${this.clients.size} total clients`);
  }
  
  private initializeOpenRouterClients(): void {
    if (!this.openRouterRegistry) return;
    
    console.log('[LLMOrchestrator] Initializing OpenRouter dynamic clients...');
    
    try {
      const openRouterModels = this.openRouterRegistry.getAvailableModels();
      let dynamicClientCount = 0;
      
      for (const modelConfig of openRouterModels) {
        try {
          // Êó¢Â≠ò„ÅÆ„ÇØ„É©„Ç§„Ç¢„É≥„Éà„Åå„Å™„ÅÑÂ†¥Âêà„ÅÆ„Åø‰ΩúÊàê
          if (!this.clients.has(modelConfig.id)) {
            const client = this.openRouterRegistry.getClient(modelConfig.id);
            if (client) {
              this.clients.set(modelConfig.id, client);
              dynamicClientCount++;
              console.log(`[LLMOrchestrator] ‚úÖ OpenRouter client initialized: ${modelConfig.id} (Tier ${modelConfig.tier})`);
            }
          }
        } catch (error) {
          console.warn(`[LLMOrchestrator] ‚ö†Ô∏è Failed to initialize OpenRouter client for ${modelConfig.id}:`, error);
        }
      }
      
      console.log(`[LLMOrchestrator] ‚úÖ Initialized ${dynamicClientCount} OpenRouter dynamic clients`);
      
    } catch (error) {
      console.error('[LLMOrchestrator] ‚ùå Failed to initialize OpenRouter clients:', error);
    }
  }

  private initializeOpenRouterRegistry(): void {
    console.log('[LLMOrchestrator] Initializing OpenRouter Model Registry...');
    
    try {
      if (process.env.OPENROUTER_API_KEY) {
        this.openRouterRegistry = OpenRouterModelRegistry.getInstance();
        // Ë®≠ÂÆö„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Åø
        const configPath = './config/openrouter-models.yaml';
        this.openRouterRegistry.loadConfig(configPath);
        
        const modelCount = this.openRouterRegistry.getAvailableModels().length;
        console.log(`[LLMOrchestrator] ‚úÖ OpenRouter Model Registry initialized with ${modelCount} models`);
      } else {
        console.warn('[LLMOrchestrator] ‚ö†Ô∏è OpenRouter API key not found - dynamic models will be unavailable');
      }
    } catch (error) {
      console.error('[LLMOrchestrator] ‚ùå Failed to initialize OpenRouter Registry:', error);
      this.openRouterRegistry = undefined;
    }
  }

  private initializeMetrics(): void {
    this.metrics = {
      requests_per_tier: { 0: 0, 1: 0, 2: 0, 3: 0 },
      success_rate_per_tier: { 0: 0, 1: 0, 2: 0, 3: 0 },
      average_latency_per_tier: { 0: 0, 1: 0, 2: 0, 3: 0 },
      cost_per_tier: { 0: 0, 1: 0, 2: 0, 3: 0 },
      total_monthly_spend: 0,
      budget_utilization_percentage: 0,
      most_used_capabilities: [],
      error_distribution: {}
    };
  }

  private initializeIntelligentAnalyzer(): void {
    console.log('[LLMOrchestrator] üß† Initializing Claude Code-driven intelligent analysis system...');
    
    this.queryAnalyzer = new ClaudeCodeQueryAnalyzer();
    this.contextAwareAnalyzer = new ContextAwareQueryAnalyzer();
    this.suitabilityAnalyzer = new ModelSuitabilityAnalyzer();
    
    console.log('[LLMOrchestrator] ‚úÖ Intelligent analysis system with context awareness initialized');
  }
  
  private initializeCollaborativeComponents(): void {
    console.log('[LLMOrchestrator] Initializing collaborative coding components...');
    
    // ÂçîË™øË®≠ÂÆö„ÅÆÂàùÊúüÂåñ
    this.collaborativeConfig = {
      difficultyThreshold: 0.6, // 60%‰ª•‰∏äeasyÂà§ÂÆö„ÅßQwen3„Å´Âßî‰ªª
      maxRetries: 2,
      qcDepth: 'full',
      maxSubtasks: 10,
      enableParallelProcessing: true,
      autoEscalateToClaudeAfterRetries: true,
      qualityThresholds: {
        minScore: 70,
        requiresReview: 85
      }
    };
    
    // „Éë„Ç§„Éó„É©„Ç§„É≥„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÅÆÂàùÊúüÂåñ
    this.taskDecomposer = new TaskDecomposer(this.collaborativeConfig);
    this.difficultyClassifier = new DifficultyClassifier(this.collaborativeConfig);
    this.qualityGate = new QualityGate(this.collaborativeConfig);
    
    console.log('[LLMOrchestrator] ‚úÖ Collaborative components initialized');
  }
  
  private initializeCapabilityRegistry(): void {
    console.log('[LLMOrchestrator] Initializing capability registry...');
    
    // CapabilityRegistry„ÅÆÂàùÊúüÂåñ
    this.capabilityRegistry = new DefaultCapabilityRegistry();
    
    try {
      // OpenAI Assistant APIÊ©üËÉΩ„ÅÆË®≠ÂÆö„ÉªÁôªÈå≤
      if (this.config.external_apis?.openai_assistant) {
        const assistantConfig = this.config.external_apis.openai_assistant;
        
        const assistantProviderConfig: AssistantConfig = {
          openai_api_key: process.env.OPENAI_API_KEY || '',
          model: assistantConfig.model || 'gpt-4o-mini',
          tools: (assistantConfig.tools || [
            { type: 'file_search' },
            { type: 'code_interpreter' }
          ]) as any,
          temperature: assistantConfig.temperature || 0.7,
          max_prompt_tokens: assistantConfig.max_prompt_tokens || 128000,
          max_completion_tokens: assistantConfig.max_completion_tokens || 4096,
          cost_per_1k_input_tokens: assistantConfig.cost_per_1k_input_tokens || 0.15,
          cost_per_1k_output_tokens: assistantConfig.cost_per_1k_output_tokens || 0.60
        };
        
        // OpenAI Assistant Provider„ÅÆ‰ΩúÊàê„ÉªÁôªÈå≤
        const assistantProvider = new OpenAIAssistantProvider(assistantProviderConfig);
        
        // ÈùûÂêåÊúü„ÅßÂàùÊúüÂåñ„ÉªÁôªÈå≤
        assistantProvider.initialize(assistantProviderConfig).then(() => {
          this.capabilityRegistry.register(assistantProvider);
          console.log('[LLMOrchestrator] ‚úÖ OpenAI Assistant capability registered');
        }).catch(error => {
          console.warn('[LLMOrchestrator] ‚ö†Ô∏è OpenAI Assistant initialization failed:', error);
        });
      }
      
      console.log('[LLMOrchestrator] ‚úÖ Capability registry initialized');
      
    } catch (error) {
      console.error('[LLMOrchestrator] ‚ùå Capability registry initialization failed:', error);
    }
  }

  private initializeRedisLogger(): void {
    console.log('[LLMOrchestrator] Initializing Redis Logger...');
    
    try {
      // Upstash RedisË®≠ÂÆö„ÇíÂÑ™ÂÖàÁöÑ„Å´Á¢∫Ë™ç
      const upstashUrl = process.env.UPSTASH_REDIS_REST_URL;
      const upstashToken = process.env.UPSTASH_REDIS_REST_TOKEN;
      
      if (upstashUrl && upstashToken) {
        console.log('[LLMOrchestrator] üöÄ Using Upstash Redis (cloud-native)');
        this.redisLogger = new UpstashRedisLogger();
        
        // ÈùûÂêåÊúüÊé•Á∂ö
        this.redisLogger.connect().catch(error => {
          console.warn('[LLMOrchestrator] Upstash Redis connection failed, falling back to local Redis:', error);
          this.fallbackToLocalRedis();
        });
        
        console.log('[LLMOrchestrator] ‚úÖ Upstash Redis Logger initialized');
      } else {
        console.log('[LLMOrchestrator] üìç Using local Redis (fallback)');
        this.fallbackToLocalRedis();
      }
    } catch (error) {
      console.error('[LLMOrchestrator] ‚ùå Redis Logger initialization failed:', error);
      this.fallbackToLocalRedis();
    }
  }

  private fallbackToLocalRedis(): void {
    try {
      const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';
      this.redisLogger = new RedisLogger(redisUrl);
      
      this.redisLogger.connect().catch(error => {
        console.warn('[LLMOrchestrator] Local Redis connection failed, logging disabled:', error);
      });
      
      console.log('[LLMOrchestrator] ‚úÖ Local Redis Logger initialized');
    } catch (error) {
      console.error('[LLMOrchestrator] ‚ùå Local Redis initialization failed:', error);
    }
  }

  private async initializeCostManagement(): Promise<void> {
    console.log('[LLMOrchestrator] Initializing precision cost management system...');
    
    try {
      // „Ç≥„Çπ„ÉàÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†„ÅÆÂàùÊúüÂåñ
      this.costManagement = new PrecisionCostManagementSystem('./data/cost-management');
      
      // ‰∫àÁÆóË®≠ÂÆö„ÅÆÂàùÊúüÂåñ
      const budgetConfig = {
        monthly_budget_usd: this.config.cost_management?.monthly_budget_usd || 70.0,
        warning_threshold: this.config.cost_management?.cost_alerts?.warning_threshold || 0.8,
        critical_threshold: this.config.cost_management?.cost_alerts?.critical_threshold || 0.95,
        auto_pause_at_limit: false,
        max_request_cost_usd: 1.0, // Âçò‰∏Ä„É™„ÇØ„Ç®„Çπ„Éà„ÅÆÊúÄÂ§ß„Ç≥„Çπ„Éà
        max_session_cost_usd: 5.0, // „Çª„ÉÉ„Ç∑„Éß„É≥Âçò‰Ωç„ÅÆÊúÄÂ§ß„Ç≥„Çπ„Éà
        budget_reset_day: 1,
        timezone: 'UTC'
      };
      
      await this.costManagement.initialize(budgetConfig);
      
      console.log('[LLMOrchestrator] ‚úÖ Cost management system initialized');
      console.log(`[LLMOrchestrator] üí∞ Monthly budget: $${budgetConfig.monthly_budget_usd}`);
      console.log(`[LLMOrchestrator] üö® Alert thresholds: ${(budgetConfig.warning_threshold * 100).toFixed(0)}% / ${(budgetConfig.critical_threshold * 100).toFixed(0)}%`);
      
    } catch (error) {
      console.error('[LLMOrchestrator] ‚ùå Failed to initialize cost management:', error);
      // Âü∫Êú¨ÁöÑ„Å™„É¢„ÉÉ„ÇØ„Ç∑„Çπ„ÉÜ„É†„ÅßÁ∂öË°å
      console.log('[LLMOrchestrator] üîÑ Continuing with basic cost tracking...');
    }
  }

  private initializeConversationManager(): void {
    console.log('[LLMOrchestrator] üí¨ Initializing Conversation Manager...');
    
    try {
      this.conversationManager = new ConversationManager(this.redisLogger);
      console.log('[LLMOrchestrator] ‚úÖ Conversation Manager initialized with Redis backend');
    } catch (error) {
      console.error('[LLMOrchestrator] ‚ùå Failed to initialize Conversation Manager:', error);
      throw error;
    }
  }

  private initializeITTroubleshootingServices(): void {
    console.log('[LLMOrchestrator] üîß Initializing IT Troubleshooting Services...');
    
    try {
      this.logAnalysisService = new LogAnalysisService();
      this.interactiveTroubleshooter = new InteractiveTroubleshooter();
      this.advancedLogAnalyzer = new AdvancedLogAnalyzer();
      this.safeExecutionManager = new SafeExecutionManager();
      
      console.log('[LLMOrchestrator] ‚úÖ IT Troubleshooting Services initialized:');
      console.log('   - Log Analysis Service');
      console.log('   - Interactive Troubleshooter');
      console.log('   - Advanced Log Analyzer');
      console.log('   - Safe Execution Manager');
    } catch (error) {
      console.error('[LLMOrchestrator] ‚ùå Failed to initialize IT Troubleshooting Services:', error);
      throw error;
    }
  }

  private printSystemSummary(): void {
    console.log('\nüöÄ === 5-Tier Hybrid LLM System Summary ===');
    
    const allModels = this.getAvailableModels();
    const modelsByTier: Record<number, ModelConfig[]> = {};
    
    // „É¢„Éá„É´„ÇíTier„Åî„Å®„Å´ÂàÜÈ°û
    for (const model of allModels) {
      if (!modelsByTier[model.tier]) {
        modelsByTier[model.tier] = [];
      }
      modelsByTier[model.tier].push(model);
    }
    
    // Tier„Åî„Å®„Å´Ë°®Á§∫
    for (let tier = 0; tier <= 3; tier++) {
      const tierModels = modelsByTier[tier] || [];
      if (tierModels.length > 0) {
        console.log(`\nTier ${tier}: ${tierModels.length} models`);
        tierModels.forEach(model => {
          const status = this.clients.has(model.id) ? '‚úÖ' : '‚ùå';
          const source = model.api_client === 'UniversalOpenRouterClient' ? '(OpenRouter)' : '(Direct)';
          console.log(`  ${status} ${model.id} ${source} - ${model.capabilities.join(', ')}`);
        });
      }
    }
    
    if (this.openRouterRegistry) {
      const orModels = this.openRouterRegistry.getAvailableModels();
      console.log(`\nüåê OpenRouter Models: ${orModels.length} available`);
    }
    
    console.log(`\nüí∞ Monthly Budget: $${this.config.cost_management.monthly_budget_usd}`);
    console.log(`üîÑ Collaboration: Cascade=${this.config.collaboration.cascade_enabled}, Refinement=${this.config.collaboration.refinement_enabled}`);
    console.log(`ü§ù Collaborative Coding: Enabled with ${this.collaborativeConfig.maxSubtasks} max subtasks`);
    console.log('==========================================\n');
  }

  async process(request: LLMRequest): Promise<LLMResponse> {
    console.log(`\nüö®üö®üö® [LLMOrchestrator] EMERGENCY TEST - Process method called! üö®üö®üö®`);
    console.log(`\n[LLMOrchestrator] Processing request: "${request.prompt.substring(0, 100)}${request.prompt.length > 100 ? '...' : ''}"`);
    console.log(`[LLMOrchestrator] Task type: ${request.task_type || 'auto'}`);
    console.log(`[LLMOrchestrator] ***** PROCESS METHOD ENTRY POINT *****`);
    
    this.requestCount++;
    const startTime = Date.now();
    
    // üÜï ‰ºöË©±„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÅÆÂá¶ÁêÜ
    let conversationContext = request.context;
    let conversationId: string | undefined;
    
    if (request.user_metadata?.session_id) {
      conversationId = request.user_metadata.session_id;
      console.log(`[LLMOrchestrator] üí¨ Using existing conversation: ${conversationId}`);
      
      // Êó¢Â≠ò‰ºöË©±„ÅÆ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÇíÂèñÂæó
      if (!conversationContext) {
        conversationContext = await this.conversationManager.buildConversationContext(conversationId);
        console.log(`[LLMOrchestrator] üìñ Built context with ${conversationContext?.turn_count || 0} turns`);
      }
    }

    // Vector StorageÁ≠â„ÅÆÊñ∞Ê©üËÉΩ„É™„ÇØ„Ç®„Çπ„Éà„Åã„ÉÅ„Çß„ÉÉ„ÇØ
    const isCapabilityReq = this.isCapabilityRequest(request);
    console.log(`[LLMOrchestrator] isCapabilityRequest: ${isCapabilityReq}`);
    if (isCapabilityReq) {
      console.log(`[LLMOrchestrator] Routing to capability provider`);
      return this.processWithCapabilityProvider(request);
    }

    // ÂçîË™ø„Ç≥„Éº„Éá„Ç£„É≥„Ç∞„ÅåÂøÖË¶Å„Åã„Å©„ÅÜ„Åã„ÇíÂà§ÂÆö
    const shouldUseCollaborativeCoding = this.shouldUseCollaborativeCoding(request);
    console.log(`[LLMOrchestrator] shouldUseCollaborativeCoding: ${shouldUseCollaborativeCoding}`);
    
    if (shouldUseCollaborativeCoding) {
      console.log(`[LLMOrchestrator] ü§ù Routing to collaborative coding pipeline`);
      
      const decompositionRequest: DecompositionRequest = {
        originalPrompt: request.prompt,
        targetLanguage: this.extractTargetLanguage(request.prompt),
        complexityPreference: 'balanced',
        maxSubtasks: this.collaborativeConfig.maxSubtasks,
        context: typeof request.context === 'string' ? request.context : undefined
      };
      
      try {
        const session = await this.processCollaborativeCoding(decompositionRequest);
        
        // CodingSession„ÇíLLMResponse„Å´Â§âÊèõ
        return this.convertSessionToResponse(session, startTime);
        
      } catch (error) {
        console.warn(`[LLMOrchestrator] Collaborative coding failed, falling back to standard processing:`, error);
        // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Åó„Å¶ÈÄöÂ∏∏Âá¶ÁêÜ„ÇíÂÆüË°å
      }
    }

    try {
      // 1. üÜï „Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàËÄÉÊÖÆÂûã„ÅÆÁü•ÁöÑ„Çø„Çπ„ÇØÂàÜÊûê
      console.log(`[LLMOrchestrator] üîç DETAILED DEBUG - Request task_type: ${request.task_type}`);
      console.log(`[LLMOrchestrator] üîç DETAILED DEBUG - Request prompt (first 50 chars): ${request.prompt.substring(0, 50)}`);
      
      let { taskType, analysis } = await this.classifyTaskIntelligently(request);
      
      // üÜï ‰ºöË©±„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„ÄÅ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàËÄÉÊÖÆÂàÜÊûê„ÇíÂÆüË°å
      if (conversationContext) {
        console.log(`[LLMOrchestrator] üß† Performing context-aware analysis...`);
        analysis = await this.contextAwareAnalyzer.analyzeWithContext(request, conversationContext);
        
        // Ë§áÈõëÂ∫¶„Ç®„Çπ„Ç´„É¨„Éº„Ç∑„Éß„É≥„Å´„Çà„Çã„Çø„Çπ„ÇØ„Çø„Ç§„ÉóÂÜçÂàÜÈ°û
        if (analysis.context_factors?.complexity_escalation && analysis.context_factors.complexity_escalation > 1.5) {
          const escalatedTaskType = this.escalateTaskType(taskType);
          if (escalatedTaskType !== taskType) {
            console.log(`[LLMOrchestrator] ‚¨ÜÔ∏è Task type escalated: ${taskType} ‚Üí ${escalatedTaskType}`);
            taskType = escalatedTaskType;
          }
        }
      }
      
      console.log(`[LLMOrchestrator] üéØ Task intelligently classified as: ${taskType}`);

      // 2. Áü•ÁöÑ„É¢„Éá„É´ÈÅ∏ÊäûÔºàÂàÜÊûêÁµêÊûú„ÇíÊ¥ªÁî®Ôºâ
      console.log(`[LLMOrchestrator] üîÑ About to call intelligent model selection with analysis...`);
      const selectedModel = await this.selectBestModelIntelligently(request, taskType, analysis);
      console.log(`[LLMOrchestrator] ‚úÖ Selected model: ${selectedModel.id} (Tier ${selectedModel.tier})`);

      // 3. „ÇØ„Ç®„É™ÂàÜÊûê„Éà„É¨„Éº„Çπ„É≠„Ç∞ÔºàRedisÔºâ
      const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      await this.logQueryAnalysis(requestId, request, analysis, selectedModel, taskType);

      // 4. ‰∫àÁÆó„ÉÅ„Çß„ÉÉ„ÇØ
      if (!this.checkBudget(selectedModel)) {
        console.warn('[LLMOrchestrator] Budget exceeded, attempting fallback...');
        const fallbackModel = this.selectFallbackModel(selectedModel);
        if (!fallbackModel) {
          throw new Error('Budget exceeded and no fallback available');
        }
        return this.executeRequest(request, fallbackModel);
      }

      // 5. „É™„ÇØ„Ç®„Çπ„ÉàÂÆüË°å
      const response = await this.executeRequest(request, selectedModel);

      // 6. ÂìÅË≥™Ë©ï‰æ°„Å®„Ç´„Çπ„Ç±„Éº„ÉâÂà§ÂÆö
      if (this.shouldCascade(response, selectedModel)) {
        console.log('[LLMOrchestrator] Quality threshold not met, cascading to higher tier...');
        const cascadedResponse = await this.cascadeToHigherTier(request, selectedModel, response);
        
        // „Ç´„Çπ„Ç±„Éº„ÉâÂæå„ÇÇ‰ºöË©±Â±•Ê≠¥„Å´Ë®òÈå≤
        if (conversationId && cascadedResponse.success) {
          try {
            await this.conversationManager.addTurn(conversationId, request, cascadedResponse);
            console.log(`[LLMOrchestrator] üíæ Cascaded turn saved to conversation ${conversationId}`);
          } catch (convError) {
            console.warn(`[LLMOrchestrator] ‚ö†Ô∏è Failed to save cascaded conversation turn:`, convError);
          }
        }
        
        return cascadedResponse;
      }

      // 7. Ê¥óÁ∑¥ÂåñÂà§ÂÆö
      if (this.shouldRefine(response, selectedModel)) {
        console.log('[LLMOrchestrator] Applying refinement with higher tier model...');
        const refinedResponse = await this.refineWithHigherTier(request, response);
        
        // Ê¥óÁ∑¥ÂåñÂæå„ÇÇ‰ºöË©±Â±•Ê≠¥„Å´Ë®òÈå≤
        if (conversationId && refinedResponse.success) {
          try {
            await this.conversationManager.addTurn(conversationId, request, refinedResponse);
            console.log(`[LLMOrchestrator] üíæ Refined turn saved to conversation ${conversationId}`);
          } catch (convError) {
            console.warn(`[LLMOrchestrator] ‚ö†Ô∏è Failed to save refined conversation turn:`, convError);
          }
        }
        
        return refinedResponse;
      }

      // üÜï ‰ºöË©±Â±•Ê≠¥„Å´Ë®òÈå≤ÔºàÊàêÂäüÊôÇ„ÅÆ„ÅøÔºâ
      if (conversationId && response.success) {
        try {
          await this.conversationManager.addTurn(conversationId, request, response);
          console.log(`[LLMOrchestrator] üíæ Turn saved to conversation ${conversationId}`);
        } catch (convError) {
          console.warn(`[LLMOrchestrator] ‚ö†Ô∏è Failed to save conversation turn:`, convError);
        }
      }
      
      console.log(`[LLMOrchestrator] ‚úÖ Request completed successfully with ${selectedModel.id}`);
      return response;

    } catch (error) {
      console.error('[LLMOrchestrator] ‚ùå Request failed:', error);
      
      const errorResponse: LLMResponse = {
        success: false,
        model_used: 'orchestrator_error',
        tier_used: -1,
        error: {
          code: 'ORCHESTRATOR_ERROR',
          message: error instanceof Error ? error.message : 'Unknown orchestrator error'
        },
        metadata: {
          model_id: 'orchestrator_error',
          provider: 'system',
          tokens_used: { input: 0, output: 0, total: 0 },
          generated_at: new Date().toISOString(),
          tier_used: -1,
          processing_time_ms: 0,
          estimated_complexity: 0
        },
        cost_info: {
          total_cost_usd: 0,
          input_cost_usd: 0,
          output_cost_usd: 0
        },
        performance_info: {
          latency_ms: Date.now() - startTime,
          processing_time_ms: Date.now() - startTime,
          fallback_used: false
        }
      };

      return errorResponse;
    }
  }

  /**
   * Claude Code‰∏ªÂ∞é„ÅÆÁü•ÁöÑ„Çø„Çπ„ÇØÂàÜÈ°û
   * ÂæìÊù•„ÅÆÂçòÁ¥î„Ç≠„Éº„ÉØ„Éº„Éâ„Éû„ÉÉ„ÉÅ„É≥„Ç∞„Åã„Çâ„ÄÅÂ§öÊ¨°ÂÖÉÁöÑÊÑèÂõ≥ÁêÜËß£„Å∏ÈÄ≤Âåñ
   */
  private async classifyTaskIntelligently(request: LLMRequest): Promise<{taskType: TaskType, analysis: QueryAnalysis}> {
    // „É¶„Éº„Ç∂„ÉºÊòéÁ§∫ÁöÑÊåáÂÆö„ÅåÊúÄÂÑ™ÂÖà
    if (request.task_type && request.task_type !== 'auto') {
      console.log(`[LLMOrchestrator] üë§ User specified task type: ${request.task_type}`);
      
      // ÊòéÁ§∫ÁöÑÊåáÂÆö„Åß„ÇÇÂàÜÊûê„ÇíÂÆüË°åÔºàÂìÅË≥™Âêë‰∏ä„ÅÆ„Åü„ÇÅÔºâ
      const analysis = await this.queryAnalyzer.analyzeQuery(request.prompt, { userSpecified: true });
      return { taskType: request.task_type, analysis };
    }

    console.log(`[LLMOrchestrator] üß† Performing Claude Code intelligent analysis...`);
    
    // Claude Code„Å´„Çà„ÇãÊ∑±Â±§ÂàÜÊûê
    const analysis = await this.queryAnalyzer.analyzeQuery(request.prompt, request);
    
    // ÂàÜÊûêÁµêÊûú„Å´Âü∫„Å•„Åè„Çø„Çπ„ÇØ„Çø„Ç§„ÉóÊ±∫ÂÆö
    const taskType = this.determineTaskTypeFromAnalysis(analysis, request.prompt);
    
    console.log(`[LLMOrchestrator] üìä Intelligence Analysis Result:`);
    console.log(`  üéØ Task Type: ${taskType}`);
    console.log(`  üî¨ Complexity: ${analysis.complexity}`);
    console.log(`  üè∑Ô∏è  Domain: ${analysis.domain.join(', ')}`);
    console.log(`  üßÆ Required Capabilities: ${analysis.requiredCapabilities.join(', ')}`);
    console.log(`  ‚ö° Priority Balance: Accuracy=${(analysis.priorityBalance.accuracy*100).toFixed(0)}% Speed=${(analysis.priorityBalance.speed*100).toFixed(0)}% Cost=${(analysis.priorityBalance.cost*100).toFixed(0)}%`);
    console.log(`  üé® Creativity Level: ${analysis.creativityLevel}`);
    console.log(`  üí≠ Reasoning Depth: ${analysis.reasoningDepth}`);
    console.log(`  ‚è±Ô∏è  Est. Processing: ${analysis.estimatedProcessingTime.toFixed(1)}s`);
    console.log(`  üé™ Confidence: ${(analysis.confidenceScore*100).toFixed(1)}%`);
    
    return { taskType, analysis };
  }

  /**
   * ÂàÜÊûêÁµêÊûú„Åã„Çâ„Çø„Çπ„ÇØ„Çø„Ç§„Éó„ÇíÊ±∫ÂÆö„Åô„ÇãÁü•ÁöÑ„É≠„Ç∏„ÉÉ„ÇØ
   */
  private determineTaskTypeFromAnalysis(analysis: QueryAnalysis, prompt: string): TaskType {
    // GPT-5ÈÅ©Áî®„ÇíÁ©çÊ•µÁöÑ„Å´Âà§ÂÆöÔºàÂ∞ÇÈñÄÊÄß„ÉªË§áÈõëÂ∫¶„ÉªÂìÅË≥™Ë¶ÅÊ±Ç„ÅÆÁ∑èÂêàË©ï‰æ°Ôºâ
    const gpt5Indicators = [
      analysis.complexity === 'expert',
      analysis.reasoningDepth === 'deep',
      analysis.qualityRequirement === 'exceptional',
      analysis.creativityLevel === 'innovative',
      analysis.domain.length > 2, // Ë§áÊï∞Â∞ÇÈñÄÂàÜÈáé„Å´„Åæ„Åü„Åå„Çã
      analysis.priorityBalance.accuracy > 0.8, // Ê•µÈ´òÁ≤æÂ∫¶Ë¶ÅÊ±Ç
      prompt.toLowerCase().includes('Êà¶Áï•') || prompt.toLowerCase().includes('strategic'),
      prompt.toLowerCase().includes('ÈáçË¶Å') || prompt.toLowerCase().includes('critical'),
      prompt.toLowerCase().includes('ÊúÄÈ´ò') || prompt.toLowerCase().includes('ultimate'),
      analysis.estimatedProcessingTime > 20 // Èï∑ÊôÇÈñìÂá¶ÁêÜ‰∫àÊ∏¨
    ];
    
    const gpt5Score = gpt5Indicators.filter(Boolean).length;
    
    // GPT-5ÈÅ©Áî®Êù°‰ª∂„ÇíÁ∑©ÂíåÔºà2ÂÄã‰ª•‰∏ä„ÅÆÊåáÊ®ô„ÅßÈÅ©Áî®Ôºâ
    if (gpt5Score >= 2) {
      console.log(`[QueryAnalyzer] üöÄ GPT-5 selection criteria met (${gpt5Score}/10 indicators)`);
      return 'critical'; // GPT-5 Tier 4„Å´„É´„Éº„ÉÜ„Ç£„É≥„Ç∞
    }

    // Ë§áÈõëÂ∫¶„Éô„Éº„Çπ„ÅÆÂü∫Êú¨Âà§ÂÆö
    if (analysis.complexity === 'expert' || analysis.complexity === 'complex') {
      // Â∞ÇÈñÄÊÄß„ÅåÈ´ò„ÅÑÂ†¥Âêà„ÅÆË©≥Á¥∞Âà§ÂÆö
      if (analysis.requiredCapabilities.includes('coding') || analysis.domain.includes('technology')) {
        return 'coding';
      }
      
      if (analysis.intentCategory === 'analysis' || analysis.reasoningDepth === 'deep') {
        return 'complex_analysis';
      }
      
      if (analysis.qualityRequirement === 'exceptional' || analysis.priorityBalance.accuracy > 0.7) {
        return 'premium';
      }
      
      return 'complex_analysis'; // „Éá„Éï„Ç©„É´„ÉàË§áÈõë„Çø„Çπ„ÇØ
    }

    // ‰∏≠Á®ãÂ∫¶Ë§áÈõëÂ∫¶„ÅÆÂ†¥Âêà
    if (analysis.complexity === 'moderate') {
      if (analysis.requiredCapabilities.includes('coding')) {
        return 'coding';
      }
      
      if (analysis.intentCategory === 'analysis' || analysis.domain.length > 1) {
        return 'complex_analysis';
      }
      
      return 'general';
    }

    // ÂâµÈÄ†ÊÄß„ÉªÂìÅË≥™Ë¶ÅÊ±Ç„Å´„Çà„ÇãÂà§ÂÆö
    if (analysis.creativityLevel === 'creative' || analysis.creativityLevel === 'innovative') {
      if (analysis.qualityRequirement === 'exceptional') {
        return 'premium';
      }
      return 'complex_analysis';
    }

    // ÊÑèÂõ≥„Ç´„ÉÜ„Ç¥„É™„Å´„Çà„ÇãÂà§ÂÆö
    if (analysis.intentCategory === 'decision' && analysis.qualityRequirement === 'high') {
      return 'premium';
    }

    // ÂæìÊù•„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºà‰∫íÊèõÊÄßÁ∂≠ÊåÅÔºâ
    const legacyTaskType = this.classifyTaskLegacy(prompt);
    if (legacyTaskType !== 'general') {
      console.log(`[LLMOrchestrator] üìù Legacy keyword match: ${legacyTaskType}`);
      return legacyTaskType;
    }

    // „Éá„Éï„Ç©„É´„Éà
    return 'general';
  }

  /**
   * ÂæìÊù•„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ„Éô„Éº„ÇπÂàÜÈ°ûÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÁî®Ôºâ
   */
  private classifyTaskLegacy(prompt: string): TaskType {
    const promptLower = prompt.toLowerCase();

    for (const [taskType, rules] of Object.entries(this.config.routing.task_classification)) {
      const matchCount = rules.keywords.filter(keyword => 
        promptLower.includes(keyword.toLowerCase())
      ).length;
      
      if (matchCount > 0) {
        return taskType as TaskType;
      }
    }

    return 'general';
  }

  /**
   * Claude Code‰∏ªÂ∞é„ÅÆÁü•ÁöÑ„É¢„Éá„É´ÈÅ∏Êäû
   * ÂàÜÊûêÁµêÊûú„ÇíÊ¥ªÁî®„Åó„ÅüÂãïÁöÑÈÅ©ÊÄßË©ï‰æ°„Å´Âü∫„Å•„ÅèÊúÄÈÅ©„É¢„Éá„É´Ê±∫ÂÆö
   */
  private async selectBestModelIntelligently(
    request: LLMRequest, 
    taskType: TaskType, 
    analysis: QueryAnalysis
  ): Promise<ModelConfig> {
    console.log(`[LLMOrchestrator] üß† Performing intelligent model selection...`);

    // üö´ Gemini Flash‰ΩéÁ≤æÂ∫¶ÂØæÁ≠ñ: Âº∑Âà∂TierÊòáÊ†ºÊù°‰ª∂
    const forcedEscalation = this.evaluateForcedTierEscalation(taskType, analysis, request);
    
    // Âà©Áî®ÂèØËÉΩ„É¢„Éá„É´„ÅÆÂèñÂæóÔºàÊúÄÂ∞èTierÂà∂ÈôêÈÅ©Áî®Ôºâ
    const availableModels = Object.values(this.config.models)
      .filter(model => this.clients.has(model.id))
      .filter(model => model.tier >= forcedEscalation.minTier);

    console.log(`[LLMOrchestrator] üìä Available models (Tier ${forcedEscalation.minTier}+): ${availableModels.map(m => `${m.id}(T${m.tier})`).join(', ')}`);

    // Âº∑Âà∂„É¢„Éá„É´ÊåáÂÆö„Åå„ÅÇ„ÇãÂ†¥Âêà
    if (forcedEscalation.forcedModel) {
      const forcedModel = availableModels.find(m => m.id === forcedEscalation.forcedModel);
      if (forcedModel) {
        console.log(`[LLMOrchestrator] üî• FORCED ESCALATION: ${forcedModel.id} (${forcedEscalation.reasoning})`);
        return forcedModel;
      }
    }

    // ÂãïÁöÑ„É¢„Éá„É´ÈÅ©ÊÄßË©ï‰æ°
    const suitabilityScores = this.suitabilityAnalyzer.evaluateModelForTask(
      analysis,
      availableModels,
      new Map() // „É¢„Éá„É´ËÉΩÂäõ„Éû„ÉÉ„Éó
    );

    // üÜï Gemini FlashÊäëÂà∂„É≠„Ç∏„ÉÉ„ÇØ
    if (forcedEscalation.suppressLowTier) {
      suitabilityScores.forEach(score => {
        const model = availableModels.find(m => m.id === score.modelId);
        if (model && (model.id.includes('flash') || model.tier < 2)) {
          score.suitabilityScore *= 0.2; // FlashÁ≥ª„Éª‰ΩéTier„ÅØÂ§ßÂπÖÊ∏õÁÇπ
          console.log(`[LLMOrchestrator] ‚¨áÔ∏è Suppressing ${model.id} due to precision requirements`);
        }
      });
    }

    // ÈÅ©ÊÄß„Çπ„Ç≥„Ç¢È†Ü„Åß„ÇΩ„Éº„Éà
    suitabilityScores.sort((a, b) => b.suitabilityScore - a.suitabilityScore);

    console.log(`[LLMOrchestrator] üèÜ Model Suitability Rankings:`);
    suitabilityScores.forEach((score, index) => {
      console.log(`  ${index + 1}. ${score.modelId}: ${(score.suitabilityScore * 100).toFixed(1)}% (${score.reasoning})`);
      if (score.strengths.length > 0) {
        console.log(`     ‚úÖ Strengths: ${score.strengths.join(', ')}`);
      }
      if (score.weaknesses.length > 0) {
        console.log(`     ‚ö†Ô∏è  Weaknesses: ${score.weaknesses.join(', ')}`);
      }
    });

    // ÊúÄÈÅ©„É¢„Éá„É´ÈÅ∏Êäû
    const bestModel = availableModels.find(model => 
      model.id === suitabilityScores[0].modelId
    );

    if (!bestModel) {
      console.log(`[LLMOrchestrator] ‚ö†Ô∏è Intelligent selection failed, falling back to legacy method`);
      return this.selectBestModelLegacy(request, taskType);
    }

    console.log(`[LLMOrchestrator] üéØ Intelligently selected: ${bestModel.id} (Tier ${bestModel.tier}) with ${(suitabilityScores[0].suitabilityScore * 100).toFixed(1)}% suitability`);

    return bestModel;
  }

  /**
   * ÂæìÊù•„ÅÆ„É¢„Éá„É´ÈÅ∏Êäû„É≠„Ç∏„ÉÉ„ÇØÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÁî®Ôºâ
   */
  private selectBestModelLegacy(request: LLMRequest, taskType: TaskType): ModelConfig {
    console.log(`[LLMOrchestrator] ===== ENTERING selectBestModel =====`);
    console.log(`[LLMOrchestrator] üìù Input task type: ${taskType}`);
    console.log(`[LLMOrchestrator] üë§ User preferred tier: ${request.preferred_tier}`);

    // „É¶„Éº„Ç∂„Éº„ÅåÁâπÂÆö„ÅÆTier„ÇíÊåáÂÆö„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà
    if (request.preferred_tier !== undefined) {
      const tierModels = Object.values(this.config.models)
        .filter(model => model.tier === request.preferred_tier)
        .filter(modelId => this.clients.has(modelId.id));
      
      console.log(`[LLMOrchestrator] User specified tier ${request.preferred_tier}, found ${tierModels.length} available models`);
      if (tierModels.length > 0) {
        // Ë§áÊï∞„É¢„Éá„É´„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØËÉΩÂäõ„Éô„Éº„Çπ„ÅßÈÅ∏Êäû
        if (tierModels.length === 1) {
          console.log(`[LLMOrchestrator] Selected: ${tierModels[0].id} (only option in tier)`);
          return tierModels[0];
        } else {
          const selectedModel = this.selectModelByCapabilities(tierModels, taskType, request.prompt);
          console.log(`[LLMOrchestrator] Selected: ${selectedModel.id} (user tier + capabilities)`);
          return selectedModel;
        }
      }
    }

    // „Çø„Çπ„ÇØ„Çø„Ç§„Éó„Å´Âü∫„Å•„ÅÑ„ÅüÊé®Â•®Tier„ÇíÂèñÂæó
    console.log(`[LLMOrchestrator] üîç Looking up task rules for: '${taskType}'`);
    console.log(`[LLMOrchestrator] üîç Available task types: ${Object.keys(this.config.routing.task_classification).join(', ')}`);
    const taskRules = this.config.routing.task_classification[taskType];
    const defaultTier = this.config.routing.default_tier;
    const preferredTier = taskRules?.preferred_tier !== undefined ? taskRules.preferred_tier : defaultTier;

    console.log(`[LLMOrchestrator] üìã Task rules for '${taskType}':`, JSON.stringify(taskRules, null, 2));
    console.log(`[LLMOrchestrator] üéØ Default tier: ${defaultTier}`);
    console.log(`[LLMOrchestrator] üéØ Final preferred tier: ${preferredTier}`);

    // Êé®Â•®Tier„Åã„ÇâÂà©Áî®ÂèØËÉΩ„Å™„É¢„Éá„É´„ÇíÈÅ∏Êäû
    let candidateModels = Object.values(this.config.models)
      .filter(model => model.tier === preferredTier)
      .filter(model => this.clients.has(model.id));

    console.log(`[LLMOrchestrator] Tier ${preferredTier} models: ${candidateModels.map(m => m.id).join(', ')}`);
    console.log(`[LLMOrchestrator] Available clients: ${Array.from(this.clients.keys()).join(', ')}`);

    // Êé®Â•®Tier„Å´„É¢„Éá„É´„Åå„Å™„ÅÑÂ†¥Âêà„ÄÅ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
    if (candidateModels.length === 0) {
      console.log(`[LLMOrchestrator] No models found in preferred tier ${preferredTier}, falling back...`);
      candidateModels = Object.values(this.config.models)
        .filter(model => this.clients.has(model.id))
        .sort((a, b) => a.tier - b.tier); // Tier„ÅÆ‰Ωé„ÅÑÈ†ÜÔºà„Ç≥„Çπ„ÉàÂäπÁéáÈáçË¶ñÔºâ
      
      console.log(`[LLMOrchestrator] Fallback candidates: ${candidateModels.map(m => `${m.id}(T${m.tier})`).join(', ')}`);
    }

    if (candidateModels.length === 0) {
      throw new Error('No available models found');
    }

    // „Çø„Çπ„ÇØ„Çø„Ç§„Éó„Å´Âü∫„Å•„ÅÑ„Å¶„Éô„Çπ„Éà„É¢„Éá„É´„ÇíÈÅ∏Êäû
    const selectedModel = this.selectModelByCapabilities(candidateModels, taskType, request.prompt);
    console.log(`[LLMOrchestrator] Final selection: ${selectedModel.id} (Tier ${selectedModel.tier})`);
    return selectedModel;
  }

  private selectModelByCapabilities(models: ModelConfig[], taskType: TaskType, prompt: string): ModelConfig {
    if (models.length === 1) {
      return models[0];
    }

    // „Çø„Çπ„ÇØ„Çø„Ç§„Éó„Å®capability„ÅÆÂØæÂøú„Éû„ÉÉ„Éî„É≥„Ç∞
    const taskCapabilityMap: Record<string, string[]> = {
      'complex_analysis': ['complex_analysis', 'advanced_reasoning', 'architectural_design'],
      'coding': ['coding', 'code_generation', 'debugging', 'code_review'],
      'general': ['general_inquiry', 'fast_processing', 'validation'],
      'premium': ['premium_analysis', 'high_quality_generation', 'strategic_planning'],
      'critical': ['critical_decisions', 'ultimate_reasoning', 'strategic_planning']
    };

    const relevantCapabilities = taskCapabilityMap[taskType] || [];

    // ÂêÑ„É¢„Éá„É´„ÅÆ„Çπ„Ç≥„Ç¢Ë®àÁÆó
    const modelScores = models.map(model => {
      let score = 0;

      // Capability „Éû„ÉÉ„ÉÅ„É≥„Ç∞
      if (model.capabilities) {
        const matches = relevantCapabilities.filter(cap => 
          model.capabilities!.includes(cap as any)
        ).length;
        score += matches * 10; // Capability „Éû„ÉÉ„ÉÅ„Åî„Å®„Å´10„Éù„Ç§„É≥„Éà
      }

      // Priority keywords „Éû„ÉÉ„ÉÅ„É≥„Ç∞
      if (model.priority_keywords && prompt) {
        const promptLower = prompt.toLowerCase();
        const keywordMatches = model.priority_keywords.filter(keyword =>
          promptLower.includes(keyword.toLowerCase())
        ).length;
        score += keywordMatches * 5; // „Ç≠„Éº„ÉØ„Éº„Éâ„Éû„ÉÉ„ÉÅ„Åî„Å®„Å´5„Éù„Ç§„É≥„Éà
      }

      // „É¨„Ç§„ÉÜ„É≥„Ç∑„Å´„Çà„ÇãËªΩÂæÆ„Å™Ë™øÊï¥Ôºà‰Ωé„É¨„Ç§„ÉÜ„É≥„Ç∑„ÅåËã•Âπ≤ÊúâÂà©Ôºâ
      score += Math.max(0, 10 - (model.latency_ms || 1000) / 100);

      return {
        model,
        score
      };
    });

    // „Çπ„Ç≥„Ç¢È†Ü„Åß„ÇΩ„Éº„Éà„Åó„Å¶ÊúÄÈ´ò„Çπ„Ç≥„Ç¢„ÅÆ„É¢„Éá„É´„ÇíÈÅ∏Êäû
    modelScores.sort((a, b) => b.score - a.score);

    console.log(`[LLMOrchestrator] Model selection scores for task '${taskType}':`);
    modelScores.forEach(({ model, score }) => {
      console.log(`  ${model.id}: ${score.toFixed(1)} points`);
    });

    return modelScores[0].model;
  }

  private selectFallbackModel(currentModel: ModelConfig): ModelConfig | null {
    // „Çà„Çä‰Ωé„ÅÑTier„ÅÆ„É¢„Éá„É´„ÇíÊé¢„Åô
    const fallbackModels = Object.values(this.config.models)
      .filter(model => model.tier < currentModel.tier)
      .filter(model => this.clients.has(model.id))
      .sort((a, b) => b.tier - a.tier); // È´ò„ÅÑTier„Åã„ÇâÈ†Ü„Å´

    return fallbackModels.length > 0 ? fallbackModels[0] : null;
  }

  private async executeRequest(request: LLMRequest, modelConfig: ModelConfig, sessionId?: string): Promise<LLMResponse> {
    console.log(`[LLMOrchestrator] üéØ executeRequest DEBUG - modelConfig.id: ${modelConfig.id}`);
    console.log(`[LLMOrchestrator] üéØ executeRequest DEBUG - available clients: ${Array.from(this.clients.keys()).join(', ')}`);
    
    const client = this.clients.get(modelConfig.id);
    console.log(`[LLMOrchestrator] üéØ executeRequest DEBUG - found client: ${client ? 'YES' : 'NO'}`);
    
    if (!client) {
      throw new Error(`Client not available for model: ${modelConfig.id}`);
    }

    // „É™„ÇØ„Ç®„Çπ„ÉàÂâç„ÅÆ„Ç≥„Çπ„Éà„ÉÅ„Çß„ÉÉ„ÇØ
    const inputTokens = Math.ceil(request.prompt.length / 4); // Ê¶ÇÁÆó
    
    // „Çø„Çπ„ÇØ„Çø„Ç§„Éó„Å®ÂÖ•ÂäõÈï∑„Å´Âü∫„Å•„ÅèÁèæÂÆüÁöÑ„Å™Âá∫Âäõ„Éà„Éº„ÇØ„É≥Êé®ÂÆö
    let estimatedOutputTokens: number;
    if (request.task_type === 'coding') {
      // „Ç≥„Éº„Éá„Ç£„É≥„Ç∞„Çø„Çπ„ÇØ„ÅØÂÖ•Âäõ„ÅÆ2-3ÂÄçÁ®ãÂ∫¶
      estimatedOutputTokens = Math.min(inputTokens * 2.5, 800);
    } else if (request.task_type === 'complex_analysis') {
      // ÂàÜÊûê„Çø„Çπ„ÇØ„ÅØÂÖ•Âäõ„ÅÆ1.5-2ÂÄçÁ®ãÂ∫¶  
      estimatedOutputTokens = Math.min(inputTokens * 1.8, 600);
    } else if (request.prompt.length > 1000) {
      // Èï∑„ÅÑÂÖ•Âäõ„ÅÆÂ†¥Âêà„ÅØÊØî‰æãÁöÑ„Å´Â¢óÂä†
      estimatedOutputTokens = Math.min(inputTokens * 1.2, 500);
    } else {
      // Áü≠„ÅÑÂÖ•Âäõ„ÅÆÂ†¥Âêà„ÅØÂõ∫ÂÆöÁöÑ„Å™Êé®ÂÆö
      estimatedOutputTokens = Math.min(inputTokens * 1.5 + 50, 300);
    }
    
    const estimatedTokens: Partial<TokenUsage> = {
      input: inputTokens,
      output: Math.ceil(estimatedOutputTokens)
    };

    let preCheckResult = null;
    if (this.costManagement) {
      preCheckResult = await this.costManagement.preRequestCheck(modelConfig.id, estimatedTokens);
      
      if (!preCheckResult.approved) {
        console.error(`[LLMOrchestrator] ‚ùå Request rejected by cost management: ${preCheckResult.reason}`);
        return {
          success: false,
          model_used: modelConfig.id,
          tier_used: modelConfig.tier,
          error: {
            code: 'COST_LIMIT_EXCEEDED',
            message: preCheckResult.reason || 'Request rejected due to cost constraints',
            provider_error: null,
            retry_count: 0
          },
          metadata: {
            model_id: modelConfig.id,
            provider: modelConfig.provider,
            tokens_used: { input: 0, output: 0, total: 0 },
            tier_used: modelConfig.tier,
            estimated_complexity: 1,
            processing_time_ms: 0,
            generated_at: new Date().toISOString()
          },
          cost_info: {
            total_cost_usd: 0,
            input_cost_usd: 0,
            output_cost_usd: 0
          },
          performance_info: {
            latency_ms: 0,
            processing_time_ms: 0,
            fallback_used: false
          }
        };
      }

      if (preCheckResult.warnings.length > 0) {
        console.warn(`[LLMOrchestrator] ‚ö†Ô∏è Cost warnings: ${preCheckResult.warnings.join(', ')}`);
      }
    }

    console.log(`[LLMOrchestrator] üöÄ Executing request with ${modelConfig.id}...`);
    if (preCheckResult) {
      console.log(`[LLMOrchestrator] üí∞ Estimated cost: $${preCheckResult.estimated_cost.total_cost_usd.toFixed(6)}`);
    }
    
    const startTime = Date.now();
    let response: LLMResponse;
    let success = false;
    let error: Error | undefined;

    try {
      response = await client.generate(request.prompt, {
        max_tokens: modelConfig.max_tokens,
        temperature: 0.7,
      });
      success = response.success;
    } catch (err) {
      error = err as Error;
      response = {
        success: false,
        model_used: modelConfig.id,
        tier_used: modelConfig.tier,
        error: {
          code: 'GENERATION_ERROR',
          message: error.message,
          provider_error: error,
          retry_count: 0
        },
        metadata: {
          model_id: modelConfig.id,
          provider: modelConfig.provider,
          tokens_used: { input: estimatedTokens.input || 0, output: 0, total: estimatedTokens.input || 0 },
          tier_used: modelConfig.tier,
          estimated_complexity: 1,
          processing_time_ms: Date.now() - startTime,
          generated_at: new Date().toISOString()
        },
        cost_info: {
          total_cost_usd: 0,
          input_cost_usd: 0,
          output_cost_usd: 0
        },
        performance_info: {
          latency_ms: Date.now() - startTime,
          processing_time_ms: Date.now() - startTime,
          fallback_used: false
        }
      };
    }

    const latency = Date.now() - startTime;

    // „É™„ÇØ„Ç®„Çπ„ÉàÂæå„ÅÆ„Ç≥„Çπ„ÉàÂá¶ÁêÜ
    if (this.costManagement && sessionId) {
      const actualTokens: TokenUsage = response.metadata?.tokens_used || {
        input: estimatedTokens.input || 0,
        output: success ? (estimatedTokens.output || 0) : 0,
        total: (estimatedTokens.input || 0) + (success ? (estimatedTokens.output || 0) : 0)
      };

      await this.costManagement.postRequestProcessing(
        sessionId,
        modelConfig.id,
        actualTokens,
        latency,
        success,
        error
      );
    }

    // „É°„Éà„É™„ÇØ„ÇπÊõ¥Êñ∞
    this.updateMetrics(modelConfig.tier, response);

    // Redis„É°„Éà„É™„ÇØ„ÇπÊõ¥Êñ∞
    const cost = response.cost_info?.total_cost_usd || 0;
    await this.updateRequestMetrics(modelConfig, latency, cost, success);

    console.log(`[LLMOrchestrator] ${success ? '‚úÖ' : '‚ùå'} Request completed: ${modelConfig.id}, Latency: ${latency}ms`);

    return response;
  }

  private checkBudget(modelConfig: ModelConfig): boolean {
    const currentUtilization = this.monthlySpend / this.config.cost_management.monthly_budget_usd;
    
    if (currentUtilization >= this.config.cost_management.cost_alerts.critical_threshold) {
      return false;
    }
    
    if (currentUtilization >= this.config.cost_management.cost_alerts.warning_threshold) {
      console.warn(`[LLMOrchestrator] üí∞ Warning: Budget utilization at ${(currentUtilization * 100).toFixed(1)}%`);
    }
    
    return true;
  }

  private shouldCascade(response: LLMResponse, model: ModelConfig): boolean {
    if (!this.config.collaboration.cascade_enabled) return false;
    
    // ÂìÅË≥™ÈñæÂÄ§„ÉÅ„Çß„ÉÉ„ÇØ
    const qualityThresholds = this.config.collaboration.quality_thresholds;
    
    if (!response.success) return true;
    if (!response.response_text || response.response_text.length < qualityThresholds.min_response_length) return true;
    if (response.metadata.confidence_score && response.metadata.confidence_score < qualityThresholds.min_confidence_score) return true;
    
    return false;
  }

  private shouldRefine(response: LLMResponse, model: ModelConfig): boolean {
    if (!this.config.collaboration.refinement_enabled) return false;
    if (model.tier >= 3) return false; // ÊúÄÈ´òTier„ÅØÊ¥óÁ∑¥Âåñ„Åó„Å™„ÅÑ
    if (!response.success) return false;
    
    // Tier0„ÅÆÂ†¥Âêà„ÅØ„ÄÅ„Ç≥„Éº„Éá„Ç£„É≥„Ç∞„Çø„Çπ„ÇØ„Åß„ÅÆ„ÅøÊ¥óÁ∑¥Âåñ„ÇíÊ§úË®é
    if (model.tier === 0) {
      return response.response_text?.includes('```') || false; // „Ç≥„Éº„Éâ„Éñ„É≠„ÉÉ„ÇØ„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà
    }
    
    return false;
  }

  /**
   * üÜï „Çø„Çπ„ÇØ„Çø„Ç§„Éó„Ç®„Çπ„Ç´„É¨„Éº„Ç∑„Éß„É≥
   * ‰ºöË©±„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Å´Âü∫„Å•„ÅÑ„Å¶„Çø„Çπ„ÇØ„ÅÆË§áÈõëÂ∫¶„Åå‰∏ä„Åå„Å£„ÅüÂ†¥Âêà„ÅÆÂá¶ÁêÜ
   */
  private escalateTaskType(currentTaskType: TaskType): TaskType {
    const escalationMap: Record<TaskType, TaskType> = {
      'general': 'complex_analysis',
      'coding': 'premium',
      'complex_analysis': 'premium',
      'premium': 'critical',
      'critical': 'critical', // Êó¢„Å´ÊúÄÈ´ò„É¨„Éô„É´
      'auto': 'complex_analysis',
      // „Åù„ÅÆ‰ªñ„ÅÆ„Çø„Çπ„ÇØ„Çø„Ç§„Éó„ÇÇ„Éû„ÉÉ„Éî„É≥„Ç∞
      'rag_search': 'complex_analysis',
      'document_query': 'premium',
      'semantic_search': 'complex_analysis',
      'vector_upsert': 'coding',
      'vector_delete': 'coding',
      'file_search': 'complex_analysis',
      'code_interpreter': 'premium',
      'general_assistant': 'complex_analysis',
      'code_execution': 'premium',
      'assistant_file_search': 'complex_analysis',
      'assistant_code_interpreter': 'premium',
      'assistant_chat': 'complex_analysis'
    };

    return escalationMap[currentTaskType] || currentTaskType;
  }

  /**
   * üö´ Gemini Flash‰ΩéÁ≤æÂ∫¶ÂØæÁ≠ñ: Âº∑Âà∂Tier„Ç®„Çπ„Ç´„É¨„Éº„Ç∑„Éß„É≥Ë©ï‰æ°
   * Áîª‰∏ÄÁöÑ„Å™ÊñáÂ≠óÂàó„Éû„ÉÉ„ÉÅ„É≥„Ç∞„Åß„ÅØ„Å™„Åè„ÄÅÂ§öÊ¨°ÂÖÉÂàÜÊûê„Å´„Çà„ÇãÁü•ÁöÑÂà§ÂÆö
   */
  private evaluateForcedTierEscalation(
    taskType: TaskType, 
    analysis: QueryAnalysis, 
    request: LLMRequest
  ): {
    minTier: number;
    forcedModel?: string;
    suppressLowTier: boolean;
    reasoning: string;
  } {
    const prompt = request.prompt.toLowerCase();
    let escalationScore = 0;
    const reasons: string[] = [];

    // 1. ÊòéÁ§∫ÁöÑ„Å™È´òÂìÅË≥™Ë¶ÅÊ±Ç„Çø„Çπ„ÇØ„Çø„Ç§„Éó
    const premiumTasks: Record<TaskType, number> = {
      'premium': 2,
      'critical': 3,
      'complex_analysis': 2,
      'coding': 1, // „Ç≥„Éº„Éá„Ç£„É≥„Ç∞„ÇÇ‰∏≠Á®ãÂ∫¶„ÅÆÂìÅË≥™Ë¶ÅÊ±Ç
      'general': 0,
      'auto': 0,
      'rag_search': 1,
      'document_query': 1,
      'semantic_search': 1,
      'vector_upsert': 0,
      'vector_delete': 0,
      'file_search': 1,
      'code_interpreter': 2,
      'general_assistant': 1,
      'code_execution': 2,
      'assistant_file_search': 2,
      'assistant_code_interpreter': 2,
      'assistant_chat': 1
    };

    const taskTypeTier = premiumTasks[taskType] || 0;
    if (taskTypeTier > 0) {
      escalationScore += taskTypeTier;
      reasons.push(`TaskType ${taskType} requires Tier ${taskTypeTier}+`);
    }

    // 2. ÊäÄË°ìÂ∞ÇÈñÄÁî®Ë™û„Å´„Çà„ÇãÂìÅË≥™Ë¶ÅÊ±ÇÊ§úÂá∫ÔºàÊñáÂ≠óÂàó„Éû„ÉÉ„ÉÅ„É≥„Ç∞„Åß„ÅØ„Å™„ÅèÊÑèÂë≥Ë´ñÁöÑÂàÜÊûêÔºâ
    const technicalDomains = {
      clustering: ['pacemaker', 'stonith', 'cluster', 'failover', 'ha', 'heartbeat'],
      database: ['postgresql', 'deadlock', 'transaction', 'index', 'query optimization', 'performance tuning'],
      containerization: ['docker', 'kubernetes', 'container', 'systemd', 'privileged'],
      automation: ['jenkins', 'ansible', 'ci/cd', 'pipeline', 'groovy', 'playbook'],
      networking: ['firewall', 'iptables', 'vlan', 'dns', 'routing', 'packet'],
      system_admin: ['apache', 'httpd', 'ssl', 'certificate', 'systemctl', 'journalctl']
    };

    let technicalDomainCount = 0;
    let criticalKeywordCount = 0;

    for (const [domain, keywords] of Object.entries(technicalDomains)) {
      const matchCount = keywords.filter(keyword => prompt.includes(keyword)).length;
      if (matchCount > 0) {
        technicalDomainCount++;
        criticalKeywordCount += matchCount;
      }
    }

    if (technicalDomainCount >= 2) {
      escalationScore += 2;
      reasons.push(`Multi-domain technical complexity detected (${technicalDomainCount} domains)`);
    } else if (technicalDomainCount >= 1) {
      escalationScore += 1;
      reasons.push(`Technical domain specialization required`);
    }

    // 3. Ë§áÈõëÂ∫¶„ÉªÂìÅË≥™ÂàÜÊûê„Å´Âü∫„Å•„ÅèÂà§ÂÆö
    if (analysis.complexity === 'expert' || analysis.complexity === 'complex') {
      escalationScore += 2;
      reasons.push(`High complexity analysis: ${analysis.complexity}`);
    }

    if (analysis.qualityRequirement === 'exceptional' || analysis.qualityRequirement === 'high') {
      escalationScore += 1;
      reasons.push(`Quality requirement: ${analysis.qualityRequirement}`);
    }

    if (analysis.reasoningDepth === 'deep') {
      escalationScore += 1;
      reasons.push(`Deep reasoning required`);
    }

    // 4. „Ç®„É©„ÉºËß£Êûê„ÉªË®∫Êñ≠Ë¶ÅÊ±ÇÊ§úÂá∫
    const diagnosticKeywords = [
      'error', 'fail', 'troubleshoot', 'debug', 'analyze', 'investigate',
      '„Ç®„É©„Éº', 'Â§±Êïó', 'ÂïèÈ°å', 'Ëß£Êûê', 'Ë™øÊüª', 'Ë®∫Êñ≠'
    ];
    const hasDiagnostic = diagnosticKeywords.some(keyword => prompt.includes(keyword));
    if (hasDiagnostic) {
      escalationScore += 1;
      reasons.push('Diagnostic/troubleshooting request requires precision');
    }

    // 5. ÊúÄÁµÇÂà§ÂÆö
    let minTier = 1; // „Éá„Éï„Ç©„É´„Éà
    let forcedModel: string | undefined;
    let suppressLowTier = false;

    if (escalationScore >= 5) {
      minTier = 3;
      forcedModel = 'gpt4o'; // ÊúÄÈ´òÂìÅË≥™Á¢∫Á¥Ñ
      suppressLowTier = true;
      reasons.push('CRITICAL: Forced GPT-4o selection');
    } else if (escalationScore >= 3) {
      minTier = 2;
      suppressLowTier = true;
      reasons.push('HIGH: Tier 2+ required, Flash suppressed');
    } else if (escalationScore >= 2) {
      minTier = 2;
      reasons.push('MEDIUM: Tier 2+ preferred');
    } else if (taskType === 'premium' || taskType === 'critical') {
      // ÊòéÁ§∫ÁöÑÊåáÂÆö„ÅØÂøÖ„ÅöÂÆà„Çã
      minTier = premiumTasks[taskType];
      suppressLowTier = true;
      reasons.push(`Explicit ${taskType} task type honored`);
    }

    const reasoning = reasons.join('; ');
    console.log(`[LLMOrchestrator] üî¨ Escalation Analysis: Score=${escalationScore}, MinTier=${minTier}, Reasoning=[${reasoning}]`);

    return {
      minTier,
      forcedModel,
      suppressLowTier,
      reasoning
    };
  }

  private async cascadeToHigherTier(
    request: LLMRequest, 
    failedModel: ModelConfig, 
    failedResponse: LLMResponse
  ): Promise<LLMResponse> {
    const higherTierModels = Object.values(this.config.models)
      .filter(model => model.tier > failedModel.tier)
      .filter(model => this.clients.has(model.id))
      .sort((a, b) => a.tier - b.tier); // ‰Ωé„ÅÑTier„Åã„ÇâÈ†Ü„Å´

    if (higherTierModels.length === 0) {
      console.log('[LLMOrchestrator] No higher tier models available for cascade');
      return failedResponse; // ÂÖÉ„ÅÆ„É¨„Çπ„Éù„É≥„Çπ„ÇíËøî„Åô
    }

    const nextModel = higherTierModels[0];
    console.log(`[LLMOrchestrator] Cascading from Tier ${failedModel.tier} to Tier ${nextModel.tier}`);
    
    const cascadeResponse = await this.executeRequest(request, nextModel);
    cascadeResponse.performance_info.fallback_used = true;
    cascadeResponse.performance_info.tier_escalation = true;
    
    return cascadeResponse;
  }

  private async refineWithHigherTier(request: LLMRequest, baseResponse: LLMResponse): Promise<LLMResponse> {
    const higherTierModels = Object.values(this.config.models)
      .filter(model => model.tier > baseResponse.tier_used)
      .filter(model => this.clients.has(model.id))
      .sort((a, b) => a.tier - b.tier);

    if (higherTierModels.length === 0) {
      return baseResponse;
    }

    const refinementModel = higherTierModels[0];
    const refinementPrompt = `
Please review and improve the following response:

Original Prompt: ${request.prompt}

Response to Improve:
${baseResponse.response_text}

Please provide an improved version that:
1. Maintains accuracy and correctness
2. Improves clarity and structure
3. Adds helpful details where appropriate
4. Fixes any issues or errors

Improved Response:`;

    console.log(`[LLMOrchestrator] Refining with Tier ${refinementModel.tier} model`);
    const refinedResponse = await this.executeRequest({ prompt: refinementPrompt }, refinementModel);
    
    // ÂÖÉ„ÅÆ„Ç≥„Çπ„ÉàÊÉÖÂ†±„Å®ÂêàË®à„Åô„Çã
    refinedResponse.cost_info.total_cost_usd += baseResponse.cost_info.total_cost_usd;
    refinedResponse.performance_info.tier_escalation = true;
    
    return refinedResponse;
  }

  private updateMetrics(tier: number, response: LLMResponse): void {
    this.metrics.requests_per_tier[tier]++;
    
    if (response.success) {
      this.metrics.success_rate_per_tier[tier] = 
        (this.metrics.success_rate_per_tier[tier] + 1) / this.metrics.requests_per_tier[tier];
    }
    
    this.metrics.average_latency_per_tier[tier] = 
      (this.metrics.average_latency_per_tier[tier] + response.performance_info.latency_ms) / this.metrics.requests_per_tier[tier];
    
    this.metrics.cost_per_tier[tier] += response.cost_info.total_cost_usd;
    this.monthlySpend += response.cost_info.total_cost_usd;
    
    this.metrics.total_monthly_spend = this.monthlySpend;
    this.metrics.budget_utilization_percentage = 
      (this.monthlySpend / this.config.cost_management.monthly_budget_usd) * 100;
  }

  // ÂÖ¨Èñã„É°„ÇΩ„ÉÉ„Éâ
  public async healthCheck(): Promise<{ healthy: boolean; details: Record<string, boolean> }> {
    console.log('[LLMOrchestrator] Performing health check on all clients...');
    
    const healthResults: Record<string, boolean> = {};
    
    for (const [modelId, client] of this.clients.entries()) {
      try {
        healthResults[modelId] = await client.isHealthy();
      } catch (error) {
        console.error(`[LLMOrchestrator] Health check failed for ${modelId}:`, error);
        healthResults[modelId] = false;
      }
    }
    
    const healthyCount = Object.values(healthResults).filter(Boolean).length;
    const totalCount = Object.keys(healthResults).length;
    
    console.log(`[LLMOrchestrator] Health check complete: ${healthyCount}/${totalCount} clients healthy`);
    
    return {
      healthy: healthyCount > 0, // Â∞ë„Å™„Åè„Å®„ÇÇ1„Å§„ÅÆ„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÅåÂÅ•ÂÖ®„Åß„ÅÇ„Çå„Å∞ OK
      details: healthResults
    };
  }

  public getMetrics(): SystemMetrics {
    return { ...this.metrics };
  }

  // Vector StorageÁ≠â„ÅÆÊñ∞Ê©üËÉΩ„É™„ÇØ„Ç®„Çπ„Éà„ÇíÂà§ÂÆö
  private isCapabilityRequest(request: LLMRequest): boolean {
    const capabilityTaskTypes = [
      'rag_search', 'document_query', 'semantic_search', 
      'vector_upsert', 'vector_delete'
      // Â∞ÜÊù•ÁöÑ„Å´file_search, code_execution„ÇÇËøΩÂä†
    ];
    
    return capabilityTaskTypes.includes(request.task_type || '');
  }

  // CapabilityProvider„Çí‰ΩøÁî®„Åó„Å¶„É™„ÇØ„Ç®„Çπ„Éà„ÇíÂá¶ÁêÜ
  private async processWithCapabilityProvider(request: LLMRequest): Promise<LLMResponse> {
    console.log(`[LLMOrchestrator] üîß Processing with capability provider: ${request.task_type}`);
    
    const startTime = Date.now();
    
    try {
      // ÊúÄÈÅ©„Å™CapabilityProvider„ÇíÈÅ∏Êäû
      const { provider, routing } = this.capabilityRegistry.findBestProviderWithRouting(request);
      
      if (!provider) {
        throw new Error(`No suitable capability provider found for task type: ${request.task_type}`);
      }

      console.log(`[LLMOrchestrator] Selected capability provider: ${provider.name}`);
      console.log(`[LLMOrchestrator] Routing info: ${routing.selection_reason}`);

      // „Éó„É≠„Éê„Ç§„ÉÄ„Éº„Åß„É™„ÇØ„Ç®„Çπ„Éà„ÇíÂÆüË°å
      const response = await provider.execute(request);
      
      const latency = Date.now() - startTime;

      // „É°„Éà„É™„ÇØ„Çπ„ÇíÊõ¥Êñ∞
      this.capabilityRegistry.updateMetrics(
        provider.name,
        response.success,
        latency,
        response.cost_info.total_cost_usd
      );

      // „É¨„Çπ„Éù„É≥„Çπ„Å´‰ªòÂä†ÊÉÖÂ†±„ÇíËøΩÂä†
      response.metadata = {
        ...response.metadata,
        routing_info: routing,
        capability_provider: provider.name
      };

      console.log(`[LLMOrchestrator] ‚úÖ Capability request completed: ${provider.name}, Success: ${response.success}, Cost: $${response.cost_info.total_cost_usd.toFixed(6)}`);
      
      return response;

    } catch (error) {
      console.error('[LLMOrchestrator] ‚ùå Capability request failed:', error);
      
      const errorResponse: LLMResponse = {
        success: false,
        model_used: 'capability_error',
        tier_used: -1,
        error: {
          code: 'CAPABILITY_ERROR',
          message: error instanceof Error ? error.message : 'Unknown capability error'
        },
        metadata: {
          model_id: 'capability_error',
          provider: 'system',
          tokens_used: { input: 0, output: 0, total: 0 },
          generated_at: new Date().toISOString(),
          tier_used: -1,
          processing_time_ms: 0,
          estimated_complexity: 0
        },
        cost_info: {
          total_cost_usd: 0,
          input_cost_usd: 0,
          output_cost_usd: 0
        },
        performance_info: {
          latency_ms: Date.now() - startTime,
          processing_time_ms: Date.now() - startTime,
          fallback_used: false
        }
      };

      return errorResponse;
    }
  }

  public getAvailableModels(): ModelConfig[] {
    return Object.values(this.config.models).filter(model => 
      this.clients.has(model.id)
    );
  }

  public resetMetrics(): void {
    this.initializeMetrics();
    this.monthlySpend = 0;
    this.requestCount = 0;
    console.log('[LLMOrchestrator] Metrics reset');
  }

  // ÂçîË™ø„Ç≥„Éº„Éá„Ç£„É≥„Ç∞Â∞ÇÁî®„É°„ÇΩ„ÉÉ„Éâ
  public async processCollaborativeCoding(request: DecompositionRequest): Promise<CodingSession> {
    const sessionId = `session_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    console.log(`\n[LLMOrchestrator] ü§ù Starting collaborative coding session: ${sessionId}`);
    console.log(`[LLMOrchestrator] Original prompt: "${request.originalPrompt.substring(0, 150)}${request.originalPrompt.length > 150 ? '...' : ''}"`);
    
    const session: CodingSession = {
      sessionId,
      originalRequest: request.originalPrompt,
      decomposition: {} as DecompositionResult, // ‰∏ÄÊôÇÁöÑ„Å´Á©∫„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
      subtasks: [],
      progress: {
        completed: 0,
        inProgress: 0,
        failed: 0,
        total: 0
      },
      metrics: {
        totalProcessingTime: 0,
        qwen3Usage: 0,
        claudeUsage: 0,
        totalCost: 0,
        qualityScore: 0
      },
      status: 'planning',
      startTime: new Date().toISOString()
    };

    this.activeSessions.set(sessionId, session);

    // „Ç≥„Çπ„ÉàÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†„Åß„Çª„ÉÉ„Ç∑„Éß„É≥ÈñãÂßã„ÇíÁôªÈå≤
    if (this.costManagement) {
      await this.costManagement.tracker.startSession(sessionId, {
        user_id: request.context || 'system',
        project_id: 'collaborative-coding',
        prompt: request.originalPrompt.substring(0, 500)
      });
    }

    try {
      // Step 1: „Çø„Çπ„ÇØÂàÜËß£
      console.log(`[LLMOrchestrator] Step 1: Task decomposition`);
      const decomposition = await this.taskDecomposer.decompose(request);
      session.decomposition = decomposition;
      session.subtasks = [...decomposition.subtasks];
      session.progress.total = decomposition.subtasks.length;

      // Step 2: Èõ£ÊòìÂ∫¶ÂÜçË©ï‰æ°
      console.log(`[LLMOrchestrator] Step 2: Difficulty classification`);
      const classifiedSubtasks = await this.difficultyClassifier.classifyBatch(session.subtasks);
      session.subtasks = classifiedSubtasks;

      // Step 3: „Çµ„Éñ„Çø„Çπ„ÇØ„ÅÆ‰∏¶ÂàóÂÆüË°å
      console.log(`[LLMOrchestrator] Step 3: Executing subtasks`);
      session.status = 'executing';
      await this.executeSubtasks(session);

      // Step 4: ÂÖ®‰ΩìÁöÑ„Å™ÂìÅË≥™„ÉÅ„Çß„ÉÉ„ÇØ„Å®Áµ±Âêà
      console.log(`[LLMOrchestrator] Step 4: Final quality check and integration`);
      session.status = 'reviewing';
      await this.performFinalQualityCheck(session);

      session.status = 'completed';
      session.endTime = new Date().toISOString();
      
      // „Ç≥„Çπ„ÉàÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†„Åß„Çª„ÉÉ„Ç∑„Éß„É≥ÁµÇ‰∫Ü„ÇíË®òÈå≤
      if (this.costManagement) {
        try {
          const finalSession = await this.costManagement.tracker.endSession(sessionId);
          console.log(`[LLMOrchestrator] üí∞ Final session cost: $${finalSession.total_cost.total_cost_usd.toFixed(6)}`);
          console.log(`[LLMOrchestrator] üìä Total requests: ${finalSession.total_requests}, Tokens: ${finalSession.total_tokens.total.toLocaleString()}`);
        } catch (error) {
          console.warn(`[LLMOrchestrator] ‚ö†Ô∏è Failed to finalize session cost tracking:`, error);
        }
      }
      
      console.log(`[LLMOrchestrator] üéâ Collaborative coding session completed: ${sessionId}`);
      console.log(`[LLMOrchestrator] Final metrics: Cost=$${session.metrics.totalCost.toFixed(4)}, Quality=${session.metrics.qualityScore.toFixed(1)}`);
      
      return session;

    } catch (error) {
      console.error(`[LLMOrchestrator] ‚ùå Collaborative coding session failed:`, error);
      session.status = 'failed';
      session.endTime = new Date().toISOString();
      throw error;
    }
  }

  private async executeSubtasks(session: CodingSession): Promise<void> {
    const easyTasks = session.subtasks.filter(t => t.difficulty === 'easy');
    const hardTasks = session.subtasks.filter(t => t.difficulty === 'hard');

    console.log(`[LLMOrchestrator] Executing ${easyTasks.length} easy tasks and ${hardTasks.length} hard tasks`);

    // ‰æùÂ≠òÈñ¢‰øÇ„ÇíËÄÉÊÖÆ„Åó„Å¶ÂÆüË°åÈ†ÜÂ∫è„ÇíÊ±∫ÂÆö
    const executionOrder = this.calculateExecutionOrder(session.subtasks);

    for (const subtask of executionOrder) {
      console.log(`[LLMOrchestrator] Processing subtask: ${subtask.id} (${subtask.difficulty})`);
      subtask.status = 'in_progress';
      session.progress.inProgress++;

      try {
        const result = await this.executeSubtask(subtask, session);
        subtask.result = result;
        
        // ÂìÅË≥™„ÉÅ„Çß„ÉÉ„ÇØ
        const qualityReview = await this.qualityGate.review(subtask, result);
        
        if (qualityReview.requiresRevision && subtask.retryCount < this.collaborativeConfig.maxRetries) {
          console.log(`[LLMOrchestrator] Quality check failed, retrying subtask: ${subtask.id}`);
          subtask.status = 'retry';
          subtask.retryCount++;
          subtask.feedback = qualityReview.comments;
          
          // ÂÜçÂÆüË°åÔºàÂøÖË¶Å„Å´Âøú„Åò„Å¶Claude Code„Å∏„Ç®„Çπ„Ç´„É¨„Éº„Ç∑„Éß„É≥Ôºâ
          const retryResult = await this.retrySubtask(subtask, session, qualityReview);
          subtask.result = retryResult;
        }

        if (qualityReview.passed || subtask.retryCount >= this.collaborativeConfig.maxRetries) {
          subtask.status = 'done';
          session.progress.completed++;
          session.progress.inProgress--;
        } else {
          subtask.status = 'failed';
          session.progress.failed++;
          session.progress.inProgress--;
        }

        // „Çª„ÉÉ„Ç∑„Éß„É≥„É°„Éà„É™„ÇØ„ÇπÊõ¥Êñ∞
        session.metrics.totalCost += result.metadata.tokens_used * 0.001; // Ê¶ÇÁÆó„Ç≥„Çπ„Éà
        if (result.metadata.model_used.includes('qwen')) {
          session.metrics.qwen3Usage++;
        } else {
          session.metrics.claudeUsage++;
        }

      } catch (error) {
        console.error(`[LLMOrchestrator] Subtask execution failed: ${subtask.id}`, error);
        subtask.status = 'failed';
        session.progress.failed++;
        session.progress.inProgress--;
      }
    }
  }

  private async executeSubtask(subtask: Subtask, session: CodingSession): Promise<CodeResult> {
    if (subtask.difficulty === 'easy') {
      // Qwen3 Coder„ÅßÂÆüË°åÔºàË®≠ÂÆö„Éï„Ç°„Ç§„É´„Åã„ÇâÂÆüÈöõ„ÅÆID„ÇíÁ¢∫Ë™çÔºâ
      const qwenModels = Object.entries(this.config.models).filter(([id, config]) => config.tier === 0);
      if (qwenModels.length > 0) {
        const [qwenId, qwenConfig] = qwenModels[0];
        const qwenClient = this.clients.get(qwenId);
        if (qwenClient) {
          console.log(`[LLMOrchestrator] üöÄ Delegating to Qwen3 Coder: ${subtask.id}`);
          const response = await qwenClient.generate(subtask.description);
          
          return {
            code: response.response_text || '',
            explanation: `Generated by Qwen3 Coder for: ${subtask.description}`,
            metadata: {
              model_used: qwenId,
              tier_used: 0,
              tokens_used: response.metadata.tokens_used?.total || 0,
              processing_time_ms: response.performance_info.processing_time_ms,
              confidence_score: response.metadata.confidence_score,
              estimated_complexity: 3 // Easy task baseline
            }
          };
        }
      }
    }
    
    // Claude Code„ÅßÂÆüË°åÔºàhard„Çø„Çπ„ÇØ„Åæ„Åü„ÅØQwen3„ÅåÂà©Áî®‰∏çÂèØ„ÅÆÂ†¥ÂêàÔºâ
    console.log(`[LLMOrchestrator] üß† Executing with Claude Code: ${subtask.id}`);
    
    // Âà©Áî®ÂèØËÉΩ„Å™ÊúÄÈ´òTier„ÅÆ„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÇíÊé¢„Åô
    const availableClients = Array.from(this.clients.keys());
    console.log(`[LLMOrchestrator] Available clients: ${availableClients.join(', ')}`);
    
    if (availableClients.length > 0) {
      const clientId = availableClients[0]; // ÊúÄÂàù„ÅÆÂà©Áî®ÂèØËÉΩ„Å™„ÇØ„É©„Ç§„Ç¢„É≥„Éà„Çí‰ΩøÁî®
      const client = this.clients.get(clientId)!;
      const response = await client.generate(subtask.description);
      
      return {
        code: response.response_text || '',
        explanation: `Generated by ${clientId} for: ${subtask.description}`,
        metadata: {
          model_used: clientId,
          tier_used: this.config.models[clientId]?.tier || 0,
          tokens_used: response.metadata.tokens_used?.total || 0,
          processing_time_ms: response.performance_info.processing_time_ms,
          confidence_score: response.metadata.confidence_score,
          estimated_complexity: subtask.difficulty === 'hard' ? 7 : 4
        }
      };
    }

    throw new Error(`No suitable client available for subtask: ${subtask.id}`);
  }

  private async retrySubtask(subtask: Subtask, session: CodingSession, qualityReview: any): Promise<CodeResult> {
    const shouldEscalate = this.collaborativeConfig.autoEscalateToClaudeAfterRetries && 
                          subtask.difficulty === 'easy' && 
                          subtask.retryCount >= 1;

    if (shouldEscalate) {
      console.log(`[LLMOrchestrator] üìà Escalating to Claude Code: ${subtask.id}`);
      subtask.difficulty = 'hard'; // Èõ£ÊòìÂ∫¶„Çí‰∏ÄÊôÇÁöÑ„Å´Â§âÊõ¥
      return this.executeSubtask(subtask, session);
    } else {
      console.log(`[LLMOrchestrator] üîÑ Retrying with same model: ${subtask.id}`);
      const improvedPrompt = `${subtask.description}

Previous attempt had these issues:
${qualityReview.comments}

Please address these issues and provide an improved implementation.`;
      
      subtask.description = improvedPrompt;
      return this.executeSubtask(subtask, session);
    }
  }

  private calculateExecutionOrder(subtasks: Subtask[]): Subtask[] {
    // „Éà„Éù„É≠„Ç∏„Ç´„É´„ÇΩ„Éº„Éà„Åß‰æùÂ≠òÈñ¢‰øÇ„ÇíËÄÉÊÖÆ„Åó„ÅüÂÆüË°åÈ†ÜÂ∫è„ÇíÊ±∫ÂÆö
    const visited = new Set<string>();
    const result: Subtask[] = [];
    
    const visit = (task: Subtask) => {
      if (visited.has(task.id)) return;
      
      visited.add(task.id);
      
      // ‰æùÂ≠òÈñ¢‰øÇ„ÅÆ„ÅÇ„Çã„Çø„Çπ„ÇØ„ÇíÂÖà„Å´ÂÆüË°å
      if (task.dependencies) {
        for (const depId of task.dependencies) {
          const depTask = subtasks.find(t => t.id === depId);
          if (depTask) {
            visit(depTask);
          }
        }
      }
      
      result.push(task);
    };
    
    for (const task of subtasks) {
      visit(task);
    }
    
    return result;
  }

  private async performFinalQualityCheck(session: CodingSession): Promise<void> {
    console.log(`[LLMOrchestrator] Performing final quality check for session: ${session.sessionId}`);
    
    const completedTasks = session.subtasks.filter(t => t.status === 'done' && t.result);
    let totalQualityScore = 0;
    
    for (const task of completedTasks) {
      if (task.result) {
        const review = await this.qualityGate.review(task, task.result);
        totalQualityScore += review.score;
      }
    }
    
    session.metrics.qualityScore = completedTasks.length > 0 ? totalQualityScore / completedTasks.length : 0;
  }

  public getActiveSession(sessionId: string): CodingSession | undefined {
    return this.activeSessions.get(sessionId);
  }

  public listActiveSessions(): CodingSession[] {
    return Array.from(this.activeSessions.values());
  }

  // „Éò„É´„Éë„Éº„É°„ÇΩ„ÉÉ„Éâ
  private shouldUseCollaborativeCoding(request: LLMRequest): boolean {
    // „Çø„Çπ„ÇØ„Çø„Ç§„Éó„ÅåÊòéÁ§∫ÁöÑ„Å´ÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„Åù„Çå„ÇíÂ∞äÈáç
    if (request.task_type) {
      // ÂàÜÊûêÁ≥ª„Çø„Çπ„ÇØ„ÅØÂçîË™ø„Ç≥„Éº„Éá„Ç£„É≥„Ç∞„Çí‰Ωø„Çè„Å™„ÅÑ
      const analysisTaskTypes = ['complex_analysis', 'general', 'premium', 'critical'];
      if (analysisTaskTypes.includes(request.task_type)) {
        return false;
      }
      // „Ç≥„Éº„Éá„Ç£„É≥„Ç∞Á≥ª„Çø„Çπ„ÇØ„ÅÆ„ÅøÂçîË™ø„Ç≥„Éº„Éá„Ç£„É≥„Ç∞„Çí‰ΩøÁî®
      if (request.task_type === 'coding') {
        return true;
      }
    }

    const prompt = request.prompt.toLowerCase();
    
    // ÂàÜÊûêÁ≥ª„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÂçîË™ø„Ç≥„Éº„Éá„Ç£„É≥„Ç∞„Çí‰Ωø„Çè„Å™„ÅÑ
    const analysisKeywords = [
      'analysis', 'analyze', 'explain', 'describe', 'discuss', 'theory', 'theorem',
      'mathematical', 'proof', 'demonstrate', 'show', 'calculate', 'derive',
      'ÂàÜÊûê', 'Ëß£Êûê', 'Ë™¨Êòé', 'Ëß£Ë™¨', 'ËÄÉÂØü', 'ÁêÜË´ñ', 'ÂÆöÁêÜ', 'Ë®ºÊòé', 
      'Êï∞Â≠¶', 'Ë®àÁÆó', 'Â∞éÂá∫', 'Ê§úË®é', 'Á†îÁ©∂'
    ];
    
    const hasAnalysisKeywords = analysisKeywords.some(keyword => prompt.includes(keyword));
    if (hasAnalysisKeywords) {
      return false;
    }
    
    // „Ç≥„Éº„Éá„Ç£„É≥„Ç∞„Çø„Çπ„ÇØ„ÅÆÊ§úÂá∫„Ç≠„Éº„ÉØ„Éº„Éâ
    const codingKeywords = [
      'implement', 'create', 'build', 'develop', 'code', 'function', 'class', 
      'api', 'endpoint', 'component', 'module', 'service', 'algorithm',
      'ÂÆüË£Ö', '‰ΩúÊàê', 'ÈñãÁô∫', 'ÊßãÁØâ', '„Ç≥„Éº„Éâ', 'Èñ¢Êï∞', '„ÇØ„É©„Çπ', 'API',
      '„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà', '„É¢„Ç∏„É•„Éº„É´', '„Çµ„Éº„Éì„Çπ', '„Ç¢„É´„Ç¥„É™„Ç∫„É†'
    ];
    
    const hasCodeKeywords = codingKeywords.some(keyword => prompt.includes(keyword));
    const hasCodeBlocks = prompt.includes('```') || prompt.includes('function') || prompt.includes('class ');
    
    // Èï∑„ÅÑ„Éó„É≠„É≥„Éó„Éà„ÇÇ„ÄÅÂàÜÊûêÁ≥ª„Åß„Å™„Åè„Ç≥„Éº„Éá„Ç£„É≥„Ç∞Ë¶ÅÁ¥†„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅÆ„ÅøÂçîË™ø„Ç≥„Éº„Éá„Ç£„É≥„Ç∞„Çí‰ΩøÁî®
    const isLongCodingTask = request.prompt.length > 400 && hasCodeKeywords;
    
    return hasCodeKeywords || hasCodeBlocks || isLongCodingTask;
  }

  private extractTargetLanguage(prompt: string): string {
    const prompt_lower = prompt.toLowerCase();
    
    const languageMap: Record<string, string> = {
      'typescript': 'typescript',
      'javascript': 'javascript', 
      'python': 'python',
      'java': 'java',
      'go': 'go',
      'rust': 'rust',
      'cpp': 'cpp',
      'c++': 'cpp'
    };
    
    for (const [keyword, language] of Object.entries(languageMap)) {
      if (prompt_lower.includes(keyword)) {
        return language;
      }
    }
    
    return 'typescript'; // „Éá„Éï„Ç©„É´„Éà
  }

  private convertSessionToResponse(session: CodingSession, startTime: number): LLMResponse {
    const completedTasks = session.subtasks.filter(t => t.status === 'done');
    const combinedCode = completedTasks.map(t => t.result?.code || '').join('\n\n');
    const combinedExplanation = completedTasks.map(t => 
      `${t.id}: ${t.result?.explanation || t.description}`
    ).join('\n');

    return {
      success: session.status === 'completed',
      model_used: 'collaborative_pipeline',
      tier_used: -1, // Ë§áÊï∞„É¢„Éá„É´‰ΩøÁî®
      response_text: `${combinedExplanation}\n\n--- Generated Code ---\n${combinedCode}`,
      metadata: {
        model_id: 'collaborative_pipeline',
        provider: 'hybrid',
        tokens_used: {
          input: session.subtasks.reduce((sum, t) => sum + (t.result?.metadata.tokens_used || 0), 0),
          output: session.subtasks.reduce((sum, t) => sum + (t.result?.metadata.tokens_used || 0), 0),
          total: session.subtasks.reduce((sum, t) => sum + (t.result?.metadata.tokens_used || 0), 0)
        },
        generated_at: new Date().toISOString(),
        confidence_score: session.metrics.qualityScore / 100,
        session_id: session.sessionId,
        subtasks_completed: completedTasks.length,
        qwen3_usage: session.metrics.qwen3Usage,
        claude_usage: session.metrics.claudeUsage,
        tier_used: -1,
        processing_time_ms: Date.now() - startTime,
        estimated_complexity: session.subtasks.length
      },
      cost_info: {
        total_cost_usd: session.metrics.totalCost,
        input_cost_usd: session.metrics.totalCost * 0.6,
        output_cost_usd: session.metrics.totalCost * 0.4
      },
      performance_info: {
        latency_ms: Date.now() - startTime,
        processing_time_ms: session.metrics.totalProcessingTime,
        fallback_used: false,
        collaborative_session: true
      }
    };
  }

  // ============================================
  // RedisÁµ±Âêà„É≠„Ç∞„É°„ÇΩ„ÉÉ„Éâ
  // ============================================
  
  /**
   * „ÇØ„Ç®„É™ÂàÜÊûêÁµêÊûú„ÇíRedis„Å´„Éà„É¨„Éº„Çπ„É≠„Ç∞„Å®„Åó„Å¶Ë®òÈå≤
   */
  private async logQueryAnalysis(
    requestId: string, 
    request: LLMRequest, 
    analysis: QueryAnalysis, 
    selectedModel: ModelConfig, 
    taskType: TaskType
  ): Promise<void> {
    if (!this.redisLogger) return;

    try {
      const analysisTime = Date.now();
      
      // ‰ª£Êõø„É¢„Éá„É´ÂÄôË£ú„ÇíÂèñÂæó
      const alternativeModels = Object.values(this.config.models)
        .filter(model => model.id !== selectedModel.id)
        .sort((a, b) => this.calculateModelScore(analysis, b) - this.calculateModelScore(analysis, a))
        .slice(0, 3)
        .map(model => model.id);

      const queryAnalysisLog: QueryAnalysisLog = {
        requestId,
        timestamp: analysisTime,
        complexity: analysis.complexity,
        reasoning_depth: analysis.reasoningDepth,
        creativity_level: analysis.creativityLevel,
        routing_decision: taskType,
        selected_model: selectedModel.id,
        selected_tier: selectedModel.tier,
        confidence_score: this.calculateConfidenceScore(analysis, selectedModel),
        alternative_models: alternativeModels,
        analysis_time_ms: 0, // Âæå„ÅßË®àÁÆó
        prompt_length: request.prompt.length,
        estimated_cost: this.estimateRequestCost(selectedModel, request.prompt.length),
        priority_balance: analysis.priorityBalance
      };

      await this.redisLogger.logQueryAnalysis(queryAnalysisLog);
      
      console.log(`[LLMOrchestrator] üìä Query analysis logged to Redis: ${requestId}`);
    } catch (error) {
      console.warn('[LLMOrchestrator] Failed to log query analysis:', error);
    }
  }

  /**
   * ÂàÜÊûêÁµêÊûú„Å´Âü∫„Å•„Åè„É¢„Éá„É´„Çπ„Ç≥„Ç¢Ë®àÁÆóÔºàÂ§öÊ¨°ÂÖÉË©ï‰æ°Ôºâ
   */
  private calculateModelScore(analysis: QueryAnalysis, model: ModelConfig): number {
    let score = 0;
    
    // 1. Ë§áÈõëÂ∫¶ÈÅ©ÂêàÂ∫¶Ë©ï‰æ° (0-3ÁÇπ)
    const complexityMapping = {
      'trivial': { tier0: 3, tier1: 2, tier2: 1, tier3: 0 },
      'simple': { tier0: 2, tier1: 3, tier2: 2, tier3: 1 },  
      'moderate': { tier0: 1, tier1: 2, tier2: 3, tier3: 2 },
      'complex': { tier0: 0, tier1: 1, tier2: 2, tier3: 3 },
      'expert': { tier0: 0, tier1: 0, tier2: 1, tier3: 3 }
    } as const;
    
    const tierKey = `tier${model.tier}` as keyof typeof complexityMapping['trivial'];
    const complexityScore = complexityMapping[analysis.complexity]?.[tierKey] || 0;
    score += complexityScore;
    
    // 2. Êé®Ë´ñÊ∑±Â∫¶ÈÅ©ÂêàÂ∫¶Ë©ï‰æ° (0-2ÁÇπ)
    const reasoningScores = {
      'shallow': { tier0: 2, tier1: 1, tier2: 0, tier3: 0 },
      'moderate': { tier0: 1, tier1: 2, tier2: 2, tier3: 1 },
      'deep': { tier0: 0, tier1: 1, tier2: 2, tier3: 2 }
    } as const;
    
    const reasoningScore = reasoningScores[analysis.reasoningDepth]?.[tierKey] || 0;
    score += reasoningScore;
    
    // 3. ÂâµÈÄ†ÊÄß„É¨„Éô„É´ÈÅ©ÂêàÂ∫¶Ë©ï‰æ° (0-2ÁÇπ)
    const creativityScores = {
      'factual': { tier0: 2, tier1: 2, tier2: 1, tier3: 1 },
      'analytical': { tier0: 1, tier1: 2, tier2: 2, tier3: 2 },
      'creative': { tier0: 0, tier1: 1, tier2: 2, tier3: 2 },
      'innovative': { tier0: 0, tier1: 0, tier2: 1, tier3: 2 }
    } as const;
    
    const creativityScore = creativityScores[analysis.creativityLevel]?.[tierKey] || 0;
    score += creativityScore;
    
    // 4. „Ç≥„Çπ„ÉàÂäπÁéáÊÄßË©ï‰æ° (0-2ÁÇπ„ÄÅÈáç„Åø‰ªò„Åë)
    const costEfficiency = [2, 1.5, 1, 0.5][model.tier] || 0; // tier0„ÅåÊúÄÈ´òÂäπÁéá
    const costScore = costEfficiency * analysis.priorityBalance.cost;
    score += costScore;
    
    // 5. ÈÄüÂ∫¶ÂäπÁéáÊÄßË©ï‰æ° (0-2ÁÇπ„ÄÅÈáç„Åø‰ªò„Åë)  
    const speedEfficiency = [2, 1.5, 1, 0.5][model.tier] || 0; // tier0„ÅåÊúÄÈ´òÈÄüÂ∫¶
    const speedScore = speedEfficiency * analysis.priorityBalance.speed;
    score += speedScore;
    
    // 6. Á≤æÂ∫¶ÈáçË¶ÅÂ∫¶Ë©ï‰æ° (0-2ÁÇπ„ÄÅÈáç„Åø‰ªò„Åë)
    const accuracyBonus = [0.5, 1, 1.5, 2][model.tier] || 0; // tier3„ÅåÊúÄÈ´òÁ≤æÂ∫¶
    const accuracyScore = accuracyBonus * analysis.priorityBalance.accuracy;
    score += accuracyScore;
    
    // 7. „Éâ„É°„Ç§„É≥ÁâπÂåñ„Éú„Éº„Éä„Çπ (0-1ÁÇπ)
    const domainBonus = this.calculateDomainBonus(analysis.domain, model);
    score += domainBonus;
    
    return Math.max(0, score); // Ë≤†Êï∞ÂõûÈÅø
  }

  /**
   * „Éâ„É°„Ç§„É≥ÁâπÂåñ„Éú„Éº„Éä„ÇπË®àÁÆó
   */
  private calculateDomainBonus(domains: string[], model: ModelConfig): number {
    let bonus = 0;
    
    // „Éâ„É°„Ç§„É≥Âõ∫Êúâ„ÅÆ„É¢„Éá„É´ÈÅ©ÊÄßË©ï‰æ°
    for (const domain of domains) {
      switch (domain.toLowerCase()) {
        case 'coding':
        case 'programming':
        case 'software':
          // Qwen3 Coder„ÅØÁâπ„Å´„Ç≥„Éº„Éá„Ç£„É≥„Ç∞„Å´ÂÑ™ÁßÄ
          if (model.id.includes('qwen') && model.id.includes('coder')) bonus += 0.5;
          if (model.tier === 0) bonus += 0.3; // tier0„ÅØ‰∏ÄËà¨ÁöÑ„Å´„Ç≥„Éº„Éá„Ç£„É≥„Ç∞„Å´ÈÅ©„Åó„Å¶„ÅÑ„Çã
          break;
          
        case 'strategy':
        case 'business':  
        case 'analysis':
          // GPT-4o, Claude Sonnet„ÅØÊà¶Áï•ÂàÜÊûê„Å´ÂÑ™ÁßÄ
          if (model.id.includes('gpt-4o') || model.id.includes('claude')) bonus += 0.5;
          if (model.tier >= 2) bonus += 0.3; // È´òtier„ÅØÂàÜÊûê„Å´ÈÅ©„Åó„Å¶„ÅÑ„Çã
          break;
          
        case 'creative':
        case 'writing':
        case 'content':
          // Claude, GPT„ÅØÂâµÈÄ†ÁöÑ„Çø„Çπ„ÇØ„Å´ÂÑ™ÁßÄ
          if (model.id.includes('claude') || model.id.includes('gpt')) bonus += 0.4;
          break;
          
        case 'math':
        case 'calculation':
        case 'logic':
          // Êï∞Â≠¶ÁâπÂåñ„É¢„Éá„É´„Åå„ÅÇ„ÇãÂ†¥Âêà
          if (model.id.includes('math') || model.id.includes('reasoning')) bonus += 0.5;
          break;
          
        default:
          // Ê±éÁî®„Éâ„É°„Ç§„É≥„Åß„ÅØ‰∏≠Èñìtier„ÅåÈÅ©„Åó„Å¶„ÅÑ„Çã
          if (model.tier === 1 || model.tier === 2) bonus += 0.1;
      }
    }
    
    return Math.min(bonus, 1.0); // ÊúÄÂ§ß1.0ÁÇπ
  }

  /**
   * „É¢„Éá„É´ÈÅ∏Êäû„ÅÆ‰ø°È†ºÂ∫¶„Çπ„Ç≥„Ç¢Ë®àÁÆó
   */
  private calculateConfidenceScore(analysis: QueryAnalysis, selectedModel: ModelConfig): number {
    const modelScore = this.calculateModelScore(analysis, selectedModel);
    const maxPossibleScore = 12; // ÊúÄÂ§ß„Çπ„Ç≥„Ç¢Ôºà3+2+2+2+2+1 = 12ÁÇπÔºâ
    return Math.min(modelScore / maxPossibleScore, 1.0);
  }

  /**
   * „É™„ÇØ„Ç®„Çπ„Éà„Ç≥„Çπ„ÉàÊé®ÂÆö
   */
  private estimateRequestCost(model: ModelConfig, promptLength: number): number {
    const estimatedTokens = Math.ceil(promptLength / 4) + 100; // ÂÖ•Âäõ+Âá∫Âäõ„ÅÆÊ¶ÇÁÆó
    const inputCost = (estimatedTokens * 0.7) * (model.cost_per_1k_tokens.input / 1000);
    const outputCost = (estimatedTokens * 0.3) * (model.cost_per_1k_tokens.output / 1000);
    return inputCost + outputCost;
  }

  /**
   * „É™„ÇØ„Ç®„Çπ„ÉàÂÆå‰∫ÜÂæå„ÅÆ„É°„Éà„É™„ÇØ„ÇπÊõ¥Êñ∞
   */
  private async updateRequestMetrics(
    selectedModel: ModelConfig,
    latency: number,
    cost: number,
    success: boolean,
    requestId?: string
  ): Promise<void> {
    if (!this.redisLogger) return;

    try {
      // „É¢„Éá„É´„É°„Éà„É™„ÇØ„ÇπÊõ¥Êñ∞
      await this.redisLogger.updateModelMetrics(selectedModel.id, latency, cost, success);
      
      // „Ç®„É©„ÉºÊôÇ„ÅÆ„Éà„É©„ÉÉ„Ç≠„É≥„Ç∞
      if (!success) {
        await this.redisLogger.trackError(
          'request_execution_failed',
          `Request failed for model ${selectedModel.id}`,
          { requestId, model: selectedModel.id, latency, cost }
        );
      }
      
      console.log(`[LLMOrchestrator] üìà Metrics updated for ${selectedModel.id}`);
    } catch (error) {
      console.warn('[LLMOrchestrator] Failed to update request metrics:', error);
    }
  }

  /**
   * Êó•Ê¨°„Ç≥„Çπ„ÉàÊõ¥Êñ∞„Çπ„Ç±„Ç∏„É•„Éº„É©„ÉºÈñãÂßã
   */
  private startDailyCostScheduler(): void {
    console.log('[LLMOrchestrator] Starting daily cost table scheduler...');
    
    // ÊØéÊó•ÂçàÂâç0:05„Å´„Ç≥„Çπ„Éà„ÉÜ„Éº„Éñ„É´Êõ¥Êñ∞
    const scheduleNextUpdate = () => {
      const now = new Date();
      const nextUpdate = new Date(now);
      nextUpdate.setHours(0, 5, 0, 0); // ÂçàÂâç0:05
      
      // ‰ªäÊó•„ÅÆ0:05„ÇíÈÅé„Åé„Å¶„ÅÑ„Åü„ÇâÁøåÊó•„Å´Ë®≠ÂÆö
      if (nextUpdate <= now) {
        nextUpdate.setDate(nextUpdate.getDate() + 1);
      }
      
      const timeUntilUpdate = nextUpdate.getTime() - now.getTime();
      
      console.log(`[LLMOrchestrator] üìÖ Next daily cost update scheduled: ${nextUpdate.toISOString()}`);
      
      setTimeout(async () => {
        console.log('[LLMOrchestrator] üïí Daily cost table update triggered');
        
        if (this.redisLogger) {
          try {
            await this.redisLogger.updateDailyCosts();
            console.log('[LLMOrchestrator] ‚úÖ Daily cost table updated successfully');
          } catch (error) {
            console.error('[LLMOrchestrator] ‚ùå Daily cost table update failed:', error);
          }
        }
        
        // Ê¨°„ÅÆÊõ¥Êñ∞„Çí„Çπ„Ç±„Ç∏„É•„Éº„É´
        scheduleNextUpdate();
      }, timeUntilUpdate);
    };
    
    scheduleNextUpdate();
    
    // Ëµ∑ÂãïÊôÇ„Å´„ÇÇÂç≥Â∫ß„Å´Êõ¥Êñ∞
    setTimeout(async () => {
      if (this.redisLogger) {
        try {
          await this.redisLogger.updateDailyCosts();
          console.log('[LLMOrchestrator] ‚úÖ Initial daily cost table updated');
        } catch (error) {
          console.warn('[LLMOrchestrator] ‚ö†Ô∏è Initial daily cost table update failed:', error);
        }
      }
    }, 5000); // 5ÁßíÂæå„Å´ÂÆüË°åÔºà„Ç∑„Çπ„ÉÜ„É†ÂàùÊúüÂåñÂæåÔºâ
  }

  /**
   * „É™„Ç¢„É´„Çø„Ç§„É†„É°„Éà„É™„ÇØ„ÇπÂèñÂæóÔºàÂ§ñÈÉ®APIÁî®Ôºâ
   */
  async getRealTimeMetrics(): Promise<any> {
    if (!this.redisLogger) {
      return { error: 'Redis Logger not available' };
    }
    
    return await this.redisLogger.getRealTimeMetrics();
  }

  /**
   * „ÇØ„Ç®„É™ÂàÜÊûêÂ±•Ê≠¥ÂèñÂæóÔºàÂ§ñÈÉ®APIÁî®Ôºâ
   */
  async getQueryAnalysisHistory(date: string, limit: number = 100): Promise<any> {
    if (!this.redisLogger) {
      return [];
    }
    
    return await this.redisLogger.getQueryAnalysisHistory(date, limit);
  }

  /**
   * Êó•Ê¨°„Ç≥„Çπ„Éà„É¨„Éù„Éº„ÉàÂèñÂæóÔºàÂ§ñÈÉ®APIÁî®Ôºâ
   */
  async getDailyCostReport(date: string): Promise<any> {
    if (!this.redisLogger) {
      return { error: 'Redis Logger not available' };
    }
    
    const metrics = await this.redisLogger.getRealTimeMetrics();
    return metrics.dailyCosts;
  }

  /**
   * RedisÁµ±Ë®àÊÉÖÂ†±ÂèñÂæóÔºàUpstashÂØæÂøúÔºâ
   */
  async getRedisStats(): Promise<any> {
    if (!this.redisLogger) {
      return { 
        error: 'Redis Logger not available',
        service_type: 'none',
        connection_status: 'disabled'
      };
    }

    try {
      // UpstashRedisLogger„Åã„Å©„ÅÜ„Åã„ÇíÁ¢∫Ë™ç
      if (this.redisLogger instanceof UpstashRedisLogger) {
        return await this.redisLogger.getUpstashStats();
      } else {
        // „É≠„Éº„Ç´„É´Redis„ÅÆÂ†¥Âêà
        return {
          connection_status: 'connected',
          service_type: 'local_redis',
          features: [
            'local_storage',
            'standard_redis_api',
            'basic_metrics'
          ]
        };
      }
    } catch (error) {
      return {
        error: 'Failed to get Redis stats',
        connection_status: 'error',
        service_type: 'unknown',
        details: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // ============================================
  // IT Troubleshooting Áµ±Âêà„É°„ÇΩ„ÉÉ„Éâ
  // ============================================

  /**
   * „É≠„Ç∞Ëß£Êûê„É™„ÇØ„Ç®„Çπ„Éà„ÇíÂá¶ÁêÜ
   */
  async processLogAnalysis(request: LogAnalysisRequest): Promise<any> {
    console.log('[LLMOrchestrator] üîç Processing log analysis request...');
    return await this.logAnalysisService.analyzeLog(request);
  }

  /**
   * È´òÂ∫¶„Å™„É≠„Ç∞Ëß£Êûê„ÇíÂÆüË°å
   */
  async processAdvancedLogAnalysis(rawLogs: string, context: LogAnalysisContext): Promise<any> {
    console.log('[LLMOrchestrator] üîß Processing advanced log analysis...');
    return await this.advancedLogAnalyzer.analyzeUserLogs(rawLogs, context);
  }

  /**
   * ÂØæË©±Âûã„Éà„É©„Éñ„É´„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÈñãÂßã
   */
  async startTroubleshootingSession(problemDescription: string, userId?: string): Promise<any> {
    console.log('[LLMOrchestrator] üõ†Ô∏è Starting troubleshooting session...');
    return await this.interactiveTroubleshooter.startTroubleshootingSession(problemDescription, userId);
  }

  /**
   * „Éà„É©„Éñ„É´„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞„Çª„ÉÉ„Ç∑„Éß„É≥„Å´ÂõûÁ≠î
   */
  async respondToTroubleshootingSession(sessionId: string, userResponse: string): Promise<any> {
    console.log('[LLMOrchestrator] üí¨ Responding to troubleshooting session...');
    
    // „Çª„ÉÉ„Ç∑„Éß„É≥Áä∂ÊÖã„ÇíÂèñÂæó„Åó„Å¶ÈÅ©Âàá„Å™Âá¶ÁêÜ„ÇíÂà§ÂÆö
    const session = this.interactiveTroubleshooter.getSessionStatus(sessionId);
    if (!session) {
      throw new Error(`Session ${sessionId} not found`);
    }

    // ÁèæÂú®„ÅØ„Ç∑„É≥„Éó„É´„Å™Ë®∫Êñ≠ÂÆüË°å„ÇíË°å„ÅÜ
    // TODO: Â∞ÜÊù•ÁöÑ„Å´„ÅØ„Çà„ÇäË©≥Á¥∞„Å™ÂØæË©±Âá¶ÁêÜ„ÇíÂÆüË£Ö
    return await this.interactiveTroubleshooter.performDiagnosis(sessionId);
  }

  /**
   * „Ç≥„Éû„É≥„Éâ„ÅÆÂÆâÂÖ®ÊÄß„ÇíË©ï‰æ°
   */
  async assessCommandSafety(command: string, context: any): Promise<any> {
    console.log('[LLMOrchestrator] üõ°Ô∏è Assessing command safety...');
    return await this.safeExecutionManager.assessCommandSafety(command);
  }

  /**
   * ITÁµ±Âêà„Ç∑„Çπ„ÉÜ„É†Áµ±Ë®àÊÉÖÂ†±ÂèñÂæó
   */
  getITSystemStats(): any {
    return {
      troubleshooting_services: {
        log_analysis: !!this.logAnalysisService,
        interactive_troubleshooter: !!this.interactiveTroubleshooter,
        advanced_log_analyzer: !!this.advancedLogAnalyzer,
        safe_execution_manager: !!this.safeExecutionManager
      },
      llm_orchestration: {
        total_models: this.clients.size,
        tiers_available: [0, 1, 2, 3],
        collaborative_coding: true,
        cost_management: !!this.costManagement
      },
      integration_status: 'fully_integrated'
    };
  }

  // ============================================
  // CLI „Ç§„É≥„Çø„Éº„Éï„Çß„Éº„ÇπÁÆ°ÁêÜ„É°„ÇΩ„ÉÉ„Éâ - REMOVED
  // All CLI functionality moved to ToolOrchestratorService
  // ============================================
  
  // processCLIRequest, selectOptimalCLI, startCLISession, 
  // getCLIStats, switchToGeminiCLI methods removed
  // Use ToolOrchestratorService for all CLI operations
}