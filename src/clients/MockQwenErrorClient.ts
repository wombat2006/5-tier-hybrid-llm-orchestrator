import { 
  BaseLLMClient, 
  LLMResponse, 
  GenerationOptions, 
  UsageStats,
  CostInfo,
  PerformanceInfo
} from '../types';

export class MockQwenErrorClient implements BaseLLMClient {
  private stats: UsageStats;
  private failureRate: number;
  private lowQualityRate: number;
  private requestCount: number = 0;

  constructor(failureRate: number = 0.3, lowQualityRate: number = 0.4) {
    this.failureRate = failureRate;
    this.lowQualityRate = lowQualityRate;
    this.stats = {
      total_requests: 0,
      successful_requests: 0,
      failed_requests: 0,
      average_latency_ms: 0,
      total_tokens_used: 0,
      total_cost_usd: 0
    };

    console.log(`[MockQwenErrorClient] 🔄 Mock Qwen3 Coder client initialized with ${(failureRate * 100).toFixed(0)}% failure rate`);
  }

  async generate(prompt: string, options: GenerationOptions = {}): Promise<LLMResponse> {
    const startTime = Date.now();
    this.stats.total_requests++;
    this.requestCount++;

    // シミュレートされた処理時間
    await new Promise(resolve => setTimeout(resolve, Math.random() * 300 + 100));

    // 失敗をシミュレート
    if (Math.random() < this.failureRate) {
      this.stats.failed_requests++;
      console.log(`[MockQwenErrorClient] ❌ Simulated failure for: "${prompt.substring(0, 50)}..."`);
      
      throw new Error(`Mock API failure - rate limit exceeded or service unavailable`);
    }

    console.log(`[MockQwenErrorClient] 🤖 Generating code for: "${prompt.substring(0, 50)}..."`);

    // 低品質なコードをシミュレート
    const isLowQuality = Math.random() < this.lowQualityRate;
    
    let mockCode = '';
    if (isLowQuality) {
      // 意図的に低品質なコードを生成
      mockCode = `
// Low quality mock code
function badFunction() {
    // TODO: implement this properly
    var x = 1;
    eval("console.log('this is bad')");  // Security issue
    return x + y; // undefined variable
}
`;
    } else {
      // 通常品質のコードを生成
      mockCode = `
# Generated by Qwen3 Coder (Mock)
# Task: ${prompt}

def example_function():
    """
    Mock code generated for demonstration purposes.
    This function would implement the requested functionality.
    """
    print("Hello from Qwen3 Coder Mock!")
    return "Success"

if __name__ == "__main__":
    result = example_function()
    print(f"Result: {result}")`;
    }

    const inputTokens = Math.floor(prompt.length / 4);
    const outputTokens = Math.floor(mockCode.length / 4);
    const totalTokens = inputTokens + outputTokens;
    
    const latency = Date.now() - startTime;
    this.stats.successful_requests++;
    this.stats.total_tokens_used += totalTokens;
    this.stats.total_cost_usd += totalTokens * 0.0001;
    this.stats.average_latency_ms = 
      (this.stats.average_latency_ms * (this.stats.successful_requests - 1) + latency) / this.stats.successful_requests;

    console.log(`[MockQwenErrorClient] ${isLowQuality ? '⚠️' : '✅'} ${isLowQuality ? 'Low-quality' : 'Success'} - Tokens: ${totalTokens}, Cost: $${(totalTokens * 0.0001).toFixed(4)}, Latency: ${latency}ms`);

    return {
      success: true,
      model_used: 'qwen3_coder_mock_error',
      tier_used: 0,
      response_text: mockCode,
      metadata: {
        model_id: 'qwen3_coder_mock_error',
        provider: 'mock',
        tokens_used: {
          input: inputTokens,
          output: outputTokens,
          total: totalTokens
        },
        confidence_score: isLowQuality ? Math.random() * 0.3 + 0.4 : Math.random() * 0.3 + 0.7, // Low quality: 0.4-0.7, Normal: 0.7-1.0
        quality_score: isLowQuality ? Math.random() * 30 + 40 : Math.random() * 30 + 70, // Low quality: 40-70, Normal: 70-100
        generated_at: new Date().toISOString(),
        tier_used: 0,
        processing_time_ms: latency,
        estimated_complexity: prompt.length / 100
      },
      cost_info: {
        total_cost_usd: totalTokens * 0.0001,
        input_cost_usd: inputTokens * 0.00005,
        output_cost_usd: outputTokens * 0.00015
      },
      performance_info: {
        latency_ms: latency,
        processing_time_ms: latency,
        fallback_used: false,
        tier_escalation: false
      }
    };
  }

  async isHealthy(): Promise<boolean> {
    // 時々健康状態もfalseを返す
    return Math.random() > 0.1; // 90%の確率で健康
  }

  async getUsageStats(): Promise<UsageStats> {
    return { ...this.stats };
  }
}