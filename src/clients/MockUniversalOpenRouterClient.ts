import { 
  BaseLLMClient, 
  LLMResponse, 
  GenerationOptions, 
  UsageStats,
  ModelConfig
} from '../types';
import { OpenRouterModelInfo } from './UniversalOpenRouterClient';

/**
 * MockUniversalOpenRouterClient - OpenRouter APIキーなしでのテスト用モッククライアント
 * 実際のAPI呼び出しなしで、OpenRouterモデルの動作をシミュレート
 */
export class MockUniversalOpenRouterClient implements BaseLLMClient {
  private modelConfig: ModelConfig;
  private stats: UsageStats;
  private openRouterModelInfo?: OpenRouterModelInfo;
  private requestCount: number = 0;

  constructor(modelConfig: ModelConfig, openRouterModelInfo?: OpenRouterModelInfo) {
    this.modelConfig = modelConfig;
    this.openRouterModelInfo = openRouterModelInfo;
    this.stats = {
      total_requests: 0,
      successful_requests: 0,
      failed_requests: 0,
      average_latency_ms: 0,
      total_tokens_used: 0,
      total_cost_usd: 0
    };

    console.log(`[MockOpenRouter] 🔄 Mock ${modelConfig.name} client initialized (testing mode)`);
  }

  async generate(prompt: string, options?: GenerationOptions): Promise<LLMResponse> {
    const startTime = Date.now();
    this.requestCount++;
    
    // モックレスポンスの生成
    const mockResponse = this.generateMockResponse(prompt, options);
    
    // 統計更新
    const processingTime = Date.now() - startTime;
    this.stats.total_requests++;
    this.stats.successful_requests++;
    this.stats.average_latency_ms = (this.stats.average_latency_ms + processingTime) / 2;
    this.stats.total_tokens_used += mockResponse.metadata.tokens_used.total;
    this.stats.total_cost_usd += mockResponse.cost_info.total_cost_usd;

    console.log(`[MockOpenRouter] 📤 Mock response generated for ${this.modelConfig.name} (${processingTime}ms)`);
    
    return mockResponse;
  }

  private generateMockResponse(prompt: string, options?: GenerationOptions): LLMResponse {
    const inputTokens = Math.ceil(prompt.length / 4);
    let outputTokens: number;
    let responseText: string;

    // モデルタイプに応じたレスポンス生成
    if (this.modelConfig.capabilities.includes('coding')) {
      outputTokens = Math.min(inputTokens * 2, 400);
      responseText = this.generateMockCodeResponse(prompt);
    } else if (this.modelConfig.capabilities.includes('creative_writing')) {
      outputTokens = Math.min(inputTokens * 1.5, 300);
      responseText = this.generateMockCreativeResponse(prompt);
    } else if (this.modelConfig.capabilities.includes('mathematics')) {
      outputTokens = Math.min(inputTokens * 1.2, 200);
      responseText = this.generateMockMathResponse(prompt);
    } else {
      outputTokens = Math.min(inputTokens * 1.3, 250);
      responseText = this.generateMockGeneralResponse(prompt);
    }

    const totalTokens = inputTokens + outputTokens;
    const inputCost = (inputTokens / 1000) * (this.openRouterModelInfo?.pricing.prompt || this.modelConfig.cost_per_1k_tokens.input);
    const outputCost = (outputTokens / 1000) * (this.openRouterModelInfo?.pricing.completion || this.modelConfig.cost_per_1k_tokens.output);

    return {
      success: true,
      model_used: this.modelConfig.name,
      tier_used: this.modelConfig.tier,
      response_text: responseText,
      metadata: {
        model_id: this.modelConfig.id,
        provider: 'openrouter_mock',
        tokens_used: {
          input: inputTokens,
          output: outputTokens,
          total: totalTokens
        },
        generated_at: new Date().toISOString(),
        session_id: `mock_session_${this.requestCount}`,
        tier_used: this.modelConfig.tier,
        processing_time_ms: 200 + Math.random() * 800, // 200-1000ms simulation
        estimated_complexity: Math.floor(Math.random() * 5) + 1,
        openrouter_model: this.openRouterModelInfo?.id,
        finish_reason: 'stop'
      },
      cost_info: {
        total_cost_usd: inputCost + outputCost,
        input_cost_usd: inputCost,
        output_cost_usd: outputCost
      },
      performance_info: {
        latency_ms: 200 + Math.random() * 800,
        processing_time_ms: 150 + Math.random() * 600,
        queue_time_ms: Math.random() * 50,
        fallback_used: false,
        tier_escalation: false
      }
    };
  }

  private generateMockCodeResponse(prompt: string): string {
    const codeSnippets = [
      `# ${this.modelConfig.name}によるコード生成例\ndef example_function(param):\n    \"\"\"Generated by ${this.modelConfig.name}\"\"\"\n    result = param * 2 + 1\n    return result\n\n# テスト例\nif __name__ == "__main__":\n    print(example_function(5))`,
      
      `// ${this.modelConfig.name} JavaScript Example\nfunction processData(input) {\n  // Mock implementation generated by ${this.modelConfig.name}\n  return input.map(item => ({\n    ...item,\n    processed: true,\n    timestamp: new Date().toISOString()\n  }));\n}\n\nmodule.exports = { processData };`,
      
      `/* ${this.modelConfig.name} - TypeScript Interface */\ninterface MockResponse {\n  id: string;\n  data: any[];\n  generated_by: '${this.modelConfig.name}';\n  created_at: string;\n}\n\nclass MockService {\n  async process(): Promise<MockResponse> {\n    return {\n      id: 'mock_' + Date.now(),\n      data: [],\n      generated_by: '${this.modelConfig.name}',\n      created_at: new Date().toISOString()\n    };\n  }\n}`
    ];
    
    return codeSnippets[Math.floor(Math.random() * codeSnippets.length)];
  }

  private generateMockGeneralResponse(prompt: string): string {
    const responses = [
      `${this.modelConfig.name}による回答:\n\nご質問「${prompt.substring(0, 50)}...」について説明いたします。\n\nこれは${this.modelConfig.name}モデルによるモック応答です。実際のAPI呼び出しは行われておらず、テスト目的でのシミュレーション応答となります。\n\n主なポイント:\n- モデル: ${this.modelConfig.name}\n- Tier: ${this.modelConfig.tier}\n- プロバイダー: OpenRouter (Mock)\n- 応答時間: シミュレーション`,
      
      `【${this.modelConfig.name}からの応答】\n\nお問い合わせ内容を確認しました。\n\n${this.modelConfig.name}は${this.modelConfig.tier === 0 ? 'コーディング特化' : this.modelConfig.tier === 1 ? '高速汎用' : this.modelConfig.tier === 2 ? '高品質推論' : '最高品質'}モデルとして、以下の機能を提供します:\n\n${this.modelConfig.capabilities.map(cap => `• ${cap}`).join('\n')}\n\n注意: これはテスト用のモック応答です。`,
      
      `${this.modelConfig.name}テストモード応答\n\nプロンプト分析結果:\n- 入力長: ${prompt.length}文字\n- 推定複雑度: ${Math.floor(Math.random() * 5) + 1}/5\n- 推奨Tier: ${this.modelConfig.tier}\n\nこの応答は${this.modelConfig.name}モデルの動作をシミュレートしたものです。実際の本番環境では、OpenRouter経由でリアルタイムに生成される高品質な応答が提供されます。`
    ];
    
    return responses[Math.floor(Math.random() * responses.length)];
  }

  private generateMockCreativeResponse(prompt: string): string {
    return `✨ ${this.modelConfig.name} - 創作モード ✨\n\n「${prompt.substring(0, 30)}...」をテーマとした創作例:\n\n昔々、とある開発者がAIシステムを構築していました。その名も「5層ハイブリッドLLMオーケストレーター」。\n\nこのシステムは${this.modelConfig.name}を含む13種類以上のAIモデルを統合し、タスクに応じて最適なモデルを自動選択する革新的なアーキテクチャでした...\n\n（※これは${this.modelConfig.name}によるクリエイティブなモック応答です）`;
  }

  private generateMockMathResponse(prompt: string): string {
    return `🔢 ${this.modelConfig.name} - 数学計算モード\n\n問題分析: ${prompt.substring(0, 50)}...\n\n解法アプローチ:\n1. 問題の定式化\n2. 適切なアルゴリズムの選択\n3. 段階的解法の実行\n\n例: 2² + 3² = 4 + 9 = 13\n\n※ 実際の計算はOpenRouter経由で${this.modelConfig.name}が実行します。これはモック例です。`;
  }

  async isHealthy(): Promise<boolean> {
    console.log(`[MockOpenRouter] ✅ ${this.modelConfig.name} health check - OK (mock)`);
    return true;
  }

  async getUsageStats(): Promise<UsageStats> {
    return { ...this.stats };
  }

  /**
   * 実際のOpenRouterクライアントへの切り替えメソッド
   * APIキーが設定されたときに動的に切り替え可能
   */
  canUpgradeToReal(): boolean {
    return !!process.env.OPENROUTER_API_KEY && 
           !process.env.OPENROUTER_API_KEY.includes('test') &&
           !process.env.OPENROUTER_API_KEY.includes('development');
  }

  getModelInfo(): { config: ModelConfig; openRouterInfo?: OpenRouterModelInfo } {
    return {
      config: this.modelConfig,
      openRouterInfo: this.openRouterModelInfo
    };
  }
}