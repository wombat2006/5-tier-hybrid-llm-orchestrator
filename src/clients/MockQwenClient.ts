import { 
  BaseLLMClient, 
  LLMResponse, 
  GenerationOptions, 
  UsageStats,
  CostInfo,
  PerformanceInfo
} from '../types';

export class MockQwenClient implements BaseLLMClient {
  private stats: UsageStats;

  constructor() {
    this.stats = {
      total_requests: 0,
      successful_requests: 0,
      failed_requests: 0,
      average_latency_ms: 0,
      total_tokens_used: 0,
      total_cost_usd: 0
    };

    console.log('[MockQwenClient] 🔄 Mock Qwen3 Coder client initialized (for testing)');
  }

  async generate(prompt: string, options: GenerationOptions = {}): Promise<LLMResponse> {
    const startTime = Date.now();
    this.stats.total_requests++;

    // シミュレートされた処理時間
    await new Promise(resolve => setTimeout(resolve, 200));

    try {
      console.log(`[MockQwenClient] 🤖 Generating code for: "${prompt.substring(0, 50)}..."`);

      // コーディングタスクを検出してモックレスポンスを生成
      let mockCode = '';
      if (prompt.toLowerCase().includes('python') || prompt.toLowerCase().includes('関数')) {
        mockCode = `
def fibonacci_sequence(n):
    """フィボナッチ数列を生成する関数
    
    Args:
        n (int): 生成する数列の長さ
        
    Returns:
        list: フィボナッチ数列のリスト
    """
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    elif n == 2:
        return [0, 1]
    
    sequence = [0, 1]
    for i in range(2, n):
        sequence.append(sequence[i-1] + sequence[i-2])
    
    return sequence

# 使用例
if __name__ == "__main__":
    result = fibonacci_sequence(10)
    print(f"フィボナッチ数列（10項）: {result}")
`;
      } else if (prompt.toLowerCase().includes('javascript') || prompt.toLowerCase().includes('js')) {
        mockCode = `
/**
 * JavaScriptでAPIレート制限を実装するクラス
 */
class RateLimiter {
    constructor(maxRequests = 100, windowMs = 60000) {
        this.maxRequests = maxRequests;
        this.windowMs = windowMs;
        this.requests = new Map();
    }

    /**
     * リクエストが許可されるかチェック
     * @param {string} clientId - クライアントID
     * @returns {boolean} - 許可されるかどうか
     */
    isAllowed(clientId) {
        const now = Date.now();
        const clientRequests = this.requests.get(clientId) || [];
        
        // ウィンドウ外の古いリクエストを削除
        const validRequests = clientRequests.filter(
            timestamp => now - timestamp < this.windowMs
        );
        
        if (validRequests.length >= this.maxRequests) {
            console.log(\`Rate limit exceeded for client: \${clientId}\`);
            return false;
        }
        
        // 新しいリクエストを記録
        validRequests.push(now);
        this.requests.set(clientId, validRequests);
        
        return true;
    }

    /**
     * クライアントの残り利用可能回数を取得
     * @param {string} clientId - クライアントID
     * @returns {number} - 残り回数
     */
    getRemainingRequests(clientId) {
        const now = Date.now();
        const clientRequests = this.requests.get(clientId) || [];
        const validRequests = clientRequests.filter(
            timestamp => now - timestamp < this.windowMs
        );
        
        return Math.max(0, this.maxRequests - validRequests.length);
    }
}

// 使用例
const rateLimiter = new RateLimiter(100, 60000); // 1分間に100リクエスト

module.exports = RateLimiter;
`;
      } else {
        mockCode = `
# Generated by Qwen3 Coder (Mock)
# Task: ${prompt}

def example_function():
    """
    Mock code generated for demonstration purposes.
    This function would implement the requested functionality.
    """
    print("Hello from Qwen3 Coder Mock!")
    return "Success"

if __name__ == "__main__":
    result = example_function()
    print(f"Result: {result}")
`;
      }

      const endTime = Date.now();
      const latency = endTime - startTime;

      // トークン数とコストの計算（モック）
      const inputTokens = Math.ceil(prompt.length / 4);
      const outputTokens = Math.ceil(mockCode.length / 4);
      const totalTokens = inputTokens + outputTokens;

      const costInfo: CostInfo = {
        input_cost_usd: (inputTokens / 1000) * 0.05,
        output_cost_usd: (outputTokens / 1000) * 0.10,
        total_cost_usd: ((inputTokens / 1000) * 0.05) + ((outputTokens / 1000) * 0.10)
      };

      const performanceInfo: PerformanceInfo = {
        latency_ms: latency,
        processing_time_ms: latency,
        fallback_used: false,
        tier_escalation: false
      };

      // 統計更新
      this.stats.successful_requests++;
      this.stats.total_tokens_used += totalTokens;
      this.stats.total_cost_usd += costInfo.total_cost_usd;
      this.updateAverageLatency(latency);

      const llmResponse: LLMResponse = {
        success: true,
        model_used: 'qwen3_coder_mock',
        tier_used: 0,
        response_text: mockCode.trim(),
        metadata: {
          model_id: 'qwen3_coder_mock',
          provider: 'mock',
          tokens_used: {
            input: inputTokens,
            output: outputTokens,
            total: totalTokens
          },
          confidence_score: 0.9,
          quality_score: 0.85,
          generated_at: new Date().toISOString(),
          tier_used: 0,
          processing_time_ms: latency,
          estimated_complexity: prompt.length / 100
        },
        cost_info: costInfo,
        performance_info: performanceInfo
      };

      console.log(`[MockQwenClient] ✅ Success - Tokens: ${totalTokens}, Cost: $${costInfo.total_cost_usd.toFixed(4)}, Latency: ${latency}ms`);
      
      return llmResponse;

    } catch (error) {
      const endTime = Date.now();
      const latency = endTime - startTime;
      
      this.stats.failed_requests++;
      this.updateAverageLatency(latency);

      console.error(`[MockQwenClient] ❌ Error:`, error);

      return {
        success: false,
        model_used: 'qwen3_coder_mock',
        tier_used: 0,
        error: {
          code: 'MOCK_ERROR',
          message: 'Mock Qwen client error',
          provider_error: error,
          retry_count: 0
        },
        metadata: {
          model_id: 'qwen3_coder_mock',
          provider: 'mock',
          tokens_used: { input: 0, output: 0, total: 0 },
          generated_at: new Date().toISOString(),
          tier_used: 0,
          processing_time_ms: 0,
          estimated_complexity: 0
        },
        cost_info: {
          total_cost_usd: 0,
          input_cost_usd: 0,
          output_cost_usd: 0
        },
        performance_info: {
          latency_ms: latency,
          processing_time_ms: latency,
          fallback_used: false
        }
      };
    }
  }

  async isHealthy(): Promise<boolean> {
    console.log('[MockQwenClient] 💚 Health check: OK (Mock)');
    return true;
  }

  async getUsageStats(): Promise<UsageStats> {
    return { ...this.stats };
  }

  private updateAverageLatency(newLatency: number): void {
    const totalRequests = this.stats.successful_requests + this.stats.failed_requests;
    this.stats.average_latency_ms = (
      (this.stats.average_latency_ms * (totalRequests - 1)) + newLatency
    ) / totalRequests;
  }

  resetStats(): void {
    this.stats = {
      total_requests: 0,
      successful_requests: 0,
      failed_requests: 0,
      average_latency_ms: 0,
      total_tokens_used: 0,
      total_cost_usd: 0
    };
  }
}