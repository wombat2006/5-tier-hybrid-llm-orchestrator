import { 
  BaseLLMClient, 
  LLMResponse, 
  GenerationOptions, 
  UsageStats,
  CostInfo,
  PerformanceInfo
} from '../types';

export class MockQwenClient implements BaseLLMClient {
  private stats: UsageStats;

  constructor() {
    this.stats = {
      total_requests: 0,
      successful_requests: 0,
      failed_requests: 0,
      average_latency_ms: 0,
      total_tokens_used: 0,
      total_cost_usd: 0
    };

    console.log('[MockQwenClient] ğŸ”„ Mock Qwen3 Coder client initialized (for testing)');
  }

  async generate(prompt: string, options: GenerationOptions = {}): Promise<LLMResponse> {
    const startTime = Date.now();
    this.stats.total_requests++;

    // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã•ã‚ŒãŸå‡¦ç†æ™‚é–“
    await new Promise(resolve => setTimeout(resolve, 200));

    try {
      console.log(`[MockQwenClient] ğŸ¤– Generating code for: "${prompt.substring(0, 50)}..."`);

      // ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¿ã‚¹ã‚¯ã‚’æ¤œå‡ºã—ã¦ãƒ¢ãƒƒã‚¯ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ç”Ÿæˆ
      let mockCode = '';
      if (prompt.toLowerCase().includes('python') || prompt.toLowerCase().includes('é–¢æ•°')) {
        mockCode = `
def fibonacci_sequence(n):
    """ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°åˆ—ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
    
    Args:
        n (int): ç”Ÿæˆã™ã‚‹æ•°åˆ—ã®é•·ã•
        
    Returns:
        list: ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°åˆ—ã®ãƒªã‚¹ãƒˆ
    """
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    elif n == 2:
        return [0, 1]
    
    sequence = [0, 1]
    for i in range(2, n):
        sequence.append(sequence[i-1] + sequence[i-2])
    
    return sequence

# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    result = fibonacci_sequence(10)
    print(f"ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°åˆ—ï¼ˆ10é …ï¼‰: {result}")
`;
      } else if (prompt.toLowerCase().includes('javascript') || prompt.toLowerCase().includes('js')) {
        mockCode = `
/**
 * JavaScriptã§APIãƒ¬ãƒ¼ãƒˆåˆ¶é™ã‚’å®Ÿè£…ã™ã‚‹ã‚¯ãƒ©ã‚¹
 */
class RateLimiter {
    constructor(maxRequests = 100, windowMs = 60000) {
        this.maxRequests = maxRequests;
        this.windowMs = windowMs;
        this.requests = new Map();
    }

    /**
     * ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒè¨±å¯ã•ã‚Œã‚‹ã‹ãƒã‚§ãƒƒã‚¯
     * @param {string} clientId - ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆID
     * @returns {boolean} - è¨±å¯ã•ã‚Œã‚‹ã‹ã©ã†ã‹
     */
    isAllowed(clientId) {
        const now = Date.now();
        const clientRequests = this.requests.get(clientId) || [];
        
        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å¤–ã®å¤ã„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‰Šé™¤
        const validRequests = clientRequests.filter(
            timestamp => now - timestamp < this.windowMs
        );
        
        if (validRequests.length >= this.maxRequests) {
            console.log(\`Rate limit exceeded for client: \${clientId}\`);
            return false;
        }
        
        // æ–°ã—ã„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è¨˜éŒ²
        validRequests.push(now);
        this.requests.set(clientId, validRequests);
        
        return true;
    }

    /**
     * ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®æ®‹ã‚Šåˆ©ç”¨å¯èƒ½å›æ•°ã‚’å–å¾—
     * @param {string} clientId - ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆID
     * @returns {number} - æ®‹ã‚Šå›æ•°
     */
    getRemainingRequests(clientId) {
        const now = Date.now();
        const clientRequests = this.requests.get(clientId) || [];
        const validRequests = clientRequests.filter(
            timestamp => now - timestamp < this.windowMs
        );
        
        return Math.max(0, this.maxRequests - validRequests.length);
    }
}

// ä½¿ç”¨ä¾‹
const rateLimiter = new RateLimiter(100, 60000); // 1åˆ†é–“ã«100ãƒªã‚¯ã‚¨ã‚¹ãƒˆ

module.exports = RateLimiter;
`;
      } else {
        mockCode = `
# Generated by Qwen3 Coder (Mock)
# Task: ${prompt}

def example_function():
    """
    Mock code generated for demonstration purposes.
    This function would implement the requested functionality.
    """
    print("Hello from Qwen3 Coder Mock!")
    return "Success"

if __name__ == "__main__":
    result = example_function()
    print(f"Result: {result}")
`;
      }

      const endTime = Date.now();
      const latency = endTime - startTime;

      // ãƒˆãƒ¼ã‚¯ãƒ³æ•°ã¨ã‚³ã‚¹ãƒˆã®è¨ˆç®—ï¼ˆãƒ¢ãƒƒã‚¯ï¼‰
      const inputTokens = Math.ceil(prompt.length / 4);
      const outputTokens = Math.ceil(mockCode.length / 4);
      const totalTokens = inputTokens + outputTokens;

      const costInfo: CostInfo = {
        input_cost_usd: (inputTokens / 1000) * 0.05,
        output_cost_usd: (outputTokens / 1000) * 0.10,
        total_cost_usd: ((inputTokens / 1000) * 0.05) + ((outputTokens / 1000) * 0.10)
      };

      const performanceInfo: PerformanceInfo = {
        latency_ms: latency,
        processing_time_ms: latency,
        fallback_used: false,
        tier_escalation: false
      };

      // çµ±è¨ˆæ›´æ–°
      this.stats.successful_requests++;
      this.stats.total_tokens_used += totalTokens;
      this.stats.total_cost_usd += costInfo.total_cost_usd;
      this.updateAverageLatency(latency);

      const llmResponse: LLMResponse = {
        success: true,
        model_used: 'qwen3_coder_mock',
        tier_used: 0,
        response_text: mockCode.trim(),
        metadata: {
          model_id: 'qwen3_coder_mock',
          provider: 'mock',
          tokens_used: {
            input: inputTokens,
            output: outputTokens,
            total: totalTokens
          },
          confidence_score: 0.9,
          quality_score: 0.85,
          generated_at: new Date().toISOString(),
          tier_used: 0,
          processing_time_ms: latency,
          estimated_complexity: prompt.length / 100
        },
        cost_info: costInfo,
        performance_info: performanceInfo
      };

      console.log(`[MockQwenClient] âœ… Success - Tokens: ${totalTokens}, Cost: $${costInfo.total_cost_usd.toFixed(4)}, Latency: ${latency}ms`);
      
      return llmResponse;

    } catch (error) {
      const endTime = Date.now();
      const latency = endTime - startTime;
      
      this.stats.failed_requests++;
      this.updateAverageLatency(latency);

      console.error(`[MockQwenClient] âŒ Error:`, error);

      return {
        success: false,
        model_used: 'qwen3_coder_mock',
        tier_used: 0,
        error: {
          code: 'MOCK_ERROR',
          message: 'Mock Qwen client error',
          provider_error: error,
          retry_count: 0
        },
        metadata: {
          model_id: 'qwen3_coder_mock',
          provider: 'mock',
          tokens_used: { input: 0, output: 0, total: 0 },
          generated_at: new Date().toISOString(),
          tier_used: 0,
          processing_time_ms: 0,
          estimated_complexity: 0
        },
        cost_info: {
          total_cost_usd: 0,
          input_cost_usd: 0,
          output_cost_usd: 0
        },
        performance_info: {
          latency_ms: latency,
          processing_time_ms: latency,
          fallback_used: false
        }
      };
    }
  }

  async isHealthy(): Promise<boolean> {
    console.log('[MockQwenClient] ğŸ’š Health check: OK (Mock)');
    return true;
  }

  async getUsageStats(): Promise<UsageStats> {
    return { ...this.stats };
  }

  private updateAverageLatency(newLatency: number): void {
    const totalRequests = this.stats.successful_requests + this.stats.failed_requests;
    this.stats.average_latency_ms = (
      (this.stats.average_latency_ms * (totalRequests - 1)) + newLatency
    ) / totalRequests;
  }

  resetStats(): void {
    this.stats = {
      total_requests: 0,
      successful_requests: 0,
      failed_requests: 0,
      average_latency_ms: 0,
      total_tokens_used: 0,
      total_cost_usd: 0
    };
  }
}